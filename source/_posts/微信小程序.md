---
date: 2019-11-11
cover: https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2455514678,1879015385&fm=26&gp=0.jpg
---

# 1.微信小程序

## 1.1 简介

微信小程序是一种不需要下载安装即可使用的应用，用户搜一搜或扫一扫即可打开应用。

![1569371811187](assets\1569371811187.png)

> **小程序与传统APP相比又有哪些优势？**

1：小程序开发成本比APP低；

2：小程序获客成本远低于APP；

3：APP开发周期慢，制作成本高、而小程序符合快速创业的精神，降低创业门槛；

4：APP生态体系已饱和，App Store排名竞争激烈，而小程序属于新生事物，发展空间充满无限想象。



> **小程序会给我们带来怎样的市场机会？**

小程序的横空出世将彻底改变微信大流量小电商的格局，近乎APP的用户体验，极低的开发和获客成本必然使原先依附于公众号、传统APP的企业和个人快速向小程序迁移，特别是 O2O 场景化应用、生活服务、工具类、社群社交类等领域的创业门槛将大大降低，一个全民创业的时代正在来临！



> **微信小程序如何推广？**

微信搜索入口：发现-->小程序-->搜索小程序



> **小程序可以做什么**

<img src="./img/weChatAppdemo.jpg">

## 1.2 小程序开发者账号注册

微信公众平台：https://mp.weixin.qq.com/

小程序开发者账号注册：https://mp.weixin.qq.com/wxopen/waregister?action=step1

在线文档：https://mp.weixin.qq.com/debug/wxadoc/dev/

微信开发工具：https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/download.html



微信小程序注册需要一个新的邮箱  (mazg1987@126.com)

![1576212410097](assets\1576212410097.png)

![1576212494534](assets\1576212494534.png)

## 1.3 微信开发工具的使用

![1569390295737](assets\1569390295737.png)



![1569373062381](assets\1569373062381.png)

![1569373346615](assets\1569373346615.png)

> 注意：
>
> 1.wechat_devtools.exe的开发体验并不好，所以我们可以用vscode进行编码，用wechat_devtools负责预览
>
> 2.我们可以在vscode中安装 --  小程序开发助手 插件来提升开发速度 。比如输入在vscode中输入 'wx-page' 会快速生成页面。其他插件：
>
>       微信小程序扩展  支持wx:if  wx:for语法
>        
>       Minapp          格式化wxml文件代码

## 1.4 微信小程序文件结构

<img src="./img/fileTree.png" />

![1569390828047](assets\1569390828047.png)

### 1.4.1 主体文件结构

主体部分由三个文件组成，必须放在项目的根目录，如下：

| 文件                                                         | 必填 | 作用                                                         |
| ------------------------------------------------------------ | ---- | ------------------------------------------------------------ |
| [app.js](https://mp.weixin.qq.com/debug/wxadoc/dev/framework/app-service/app.html) | 是   | 小程序逻辑                                                   |
| [app.json](https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html) | 是   | 小程序公共设置( 严格的JSON语法，不能用单引号，不能写注释，否则编译报错 ) |
| [app.wxss](https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxss.html) | 否   | 小程序公共样式表( **拓展了rpx尺寸单位，微信专属响应式像素** ) |

### 1.4.2 页面文件结构

页面由四个文件组成，分别是：

| 文件类型                                                     | 必填 | 作用                                                         |
| ------------------------------------------------------------ | ---- | ------------------------------------------------------------ |
| [js](https://mp.weixin.qq.com/debug/wxadoc/dev/framework/app-service/page.html) | 是   | 页面逻辑 ( 微信小程序没有window和document对象 )              |
| [wxml](https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/) | 是   | 页面结构  ( XML语法，不是HTML语法 )                          |
| [wxss](https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxss.html) | 否   | 页面样式表 ( **拓展了rpx尺寸单位，微信专属响应式像素** )     |
| [json](https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html#pagejson) | 否   | 页面配置 ( 严格的JSON语法，不能用单引号，不能写注释，否则编译报错 ) |

### 1.4.3 其他文件

project.config.json : 项目的配置文件

sitemap.json : 用来配置小程序及其页面是否允许被微信索引（上线的时候使用）

```
{
  "rules":[{
    "action": "allow",
    "page": "path/to/page"
  }, {
    "action": "disallow",
    "page": "*"
  }]
}
```

## 1.5 微信小程序配置-app.json

### 1.5.1 app.json 配置项列表

<https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html>

```javascript
{
  "pages": [
    "pages/index/index",
    "pages/logs/index"
  ],
  "window": {
    "navigationBarTitleText": "Demo"
  },
  "tabBar": {
    "color": "#dddddd",
    "selectedColor": "#3cc51f",
    "borderStyle": "black",
    "backgroundColor": "#ffffff",
    "list": [{
      "pagePath": "page/component/index",
      "iconPath": "image/icon_component.png",
      "selectedIconPath": "image/icon_component_HL.png",
      "text": "组件"
    }, {
      "pagePath": "page/API/index/index",
      "iconPath": "image/icon_API.png",
      "selectedIconPath": "image/icon_API_HL.png",
      "text": "接口"
    }]
  },
  "networkTimeout": {
    "request": 10000,
    "downloadFile": 10000
  },
  "debug": true,
  "navigateToMiniProgramAppIdList": [
    "wxe5f52902cf4de896"
  ]
}

//如果要新增页面可以直接在pages里面编辑
```

> `app.json`文件用来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。

| 属性                                       | 类型           | 必填   | 描述              |
| ---------------------------------------- | ------------ | ---- | --------------- |
| [pages](https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html#pages) | String Array | 是    | 设置页面路径          |
| [window](https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html#window) | Object       | 否    | 设置默认页面的窗口表现     |
| [tabBar](https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html#tabbar) | Object       | 否    | 设置底部 tab 的表现    |
| [debug](https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html#debug) | Boolean      | 否    | 设置是否开启 debug 模式 |

### 1.5.2 window配置

> 用于设置小程序的状态栏、导航条、标题、窗口背景色。
>
> 注意：页面的`.json`只能设置 `window` 相关的配置项，以决定本页面的窗口表现，所以无需写 `window` 这个键。

| 属性                         | 类型     | 默认值  | 描述                                                         |
| ---------------------------- | -------- | ------- | ------------------------------------------------------------ |
| navigationBarBackgroundColor | HexColor | #000000 | 导航栏背景颜色，如"#000000"                                  |
| navigationBarTextStyle       | String   | white   | 导航栏标题颜色，仅支持 black/white                           |
| navigationBarTitleText       | String   |         | 导航栏标题文字内容                                           |
| backgroundColor              | HexColor | #ffffff | 窗口的背景色，可以通过开启 "enablePullDownRefresh":true来查看窗口颜色 |
| backgroundTextStyle          | String   | dark    | 下拉刷新的背景字体、loading 图的样式，仅支持 dark/light      |
| enablePullDownRefresh        | Boolean  | false   | 是否开启下拉刷新，详见[页面相关事件处理函数](https://mp.weixin.qq.com/debug/wxadoc/dev/framework/app-service/page.html#页面相关事件处理函数)。 |
| onReachBottomDistance        | Number   | 50      | 页面上拉触底事件触发时距页面底部距离，单位为px               |

<img src="./img/config.jpg" />

### 1.5.3 tabBar

https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html#tabbar

如果小程序是一个多 tab 应用（客户端窗口的底部或顶部有 tab 栏可以切换页面），可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面。

**Tip：**

1. 当设置 position 为 top 时，将不会显示 icon。
2. tabBar 中的 list 是一个数组，**只能配置最少2个、最多5个 tab**，tab 按数组的顺序排序。

**属性说明：**

| 属性              | 类型       | 必填   | 默认值    | 描述                                 |
| --------------- | -------- | ---- | ------ | ---------------------------------- |
| color           | HexColor | 是    |        | tab 上的文字默认颜色                       |
| selectedColor   | HexColor | 是    |        | tab 上的文字选中时的颜色                     |
| backgroundColor | HexColor | 是    |        | tab 的背景色                           |
| borderStyle     | String   | 否    | black  | tabbar上边框的颜色， 仅支持 black/white      |
| list            | Array    | 是    |        | tab 的列表，详见 list 属性说明，最少2个、最多5个 tab |
| position        | String   | 否    | bottom | 可选值 bottom、top，设置成top是无图标          |

其中 list 接受一个数组，数组中的每个项都是一个对象，其属性值如下：

| 属性               | 类型     | 必填   | 说明                                       |
| ---------------- | ------ | ---- | ---------------------------------------- |
| pagePath         | String | 是    | 页面路径，必须在 pages 中先定义                      |
| text             | String | 是    | tab 上按钮文字                                |
| iconPath         | String | 否    | 图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px，当 postion 为 top 时，此参数无效 |
| selectedIconPath | String | 否    | 选中时的图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px ，当 postion 为 top 时，此参数无效 |

图示：

<img src="./img/tabBar.png" />



## 1.6 页面配置-index/index.json

在页面配置中，可以修改全局配置的部分信息，用来指定当前页面的一些特有配置

![1576219606646](assets\1576219606646.png)

<https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/page.html>

```
{
  "usingComponents": {},
  "navigationBarBackgroundColor": "#00bbaa",
  "navigationBarTitleText": "首页",
  "navigationBarTextStyle": "white"
}
```

## 1.7 微信小程序代码解析

```javascript
//1.小程序不是运行在浏览器中，所以没有window和document对象
console.log(window);
console.log(document);

//2.小程序js的一些额外成员
//App({})方法：用于创建应用程序实例，指定应用程序的生命周期
//Page()方法：用于创建页面对象
//getApp()方法：用于获取全局的应用程序对象
//getCurrentPages()方法：用于获取当前页面的调用栈 
   # https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/route.html
//wx : 微信小程序获取API的对象

//3.小程序支持CommonJS规范
//exports.aa 或者module.exports导出
//require 引入
```

# 2.页面层数据、事件

## 2.1 页面层数据绑定

https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/

```javascript
Page({
   data: {
    text: "This is page data.",
    classname:"hello",
    name:"xiaoming",
    id:1,
    flag:true
  },
})

<text>{{text}}</text>
<view class="{{classname}}"></view>
<view>{{'abc'}}</view>
<view>{{111}}</view>
<view>{{111*999}}</view>
<view>{{"hello" + name}}</view>
<view>{{flag?"真的":"假的"}}</view>
<checkbox checked="{{false}}">  //这边不能直接<checkbox checked="false">，因为js中只要不是非空字符串，他的值都是true，我们可以通过mustache插值表达式解决该问题
<view id="item-{{id}}"> </view>
<view hidden="{{flag ? true : false}}"> Hidden </view>

.hello{
  width: 100px;
  height: 100px;
  background: red;
}
```

## 2.2 wxs语法

WXS（WeiXin Script）是小程序的一套脚本语言，结合 `WXML`，可以构建出页面的结构。

WXS存在的意义就是充当compute/filter这类功能

WXS 与 JavaScript 是不同的语言，有自己的语法，并不和 JavaScript 一致。

WXS 代码可以编写在 wxml 文件中的 `<wxs>` 标签内，或以 `.wxs` 为后缀名的文件内。

<https://developers.weixin.qq.com/miniprogram/dev/reference/wxs/>

```javascript
<!--wxml-->
<wxs module="m1">
var msg = "hello world";
module.exports.message = msg;
</wxs>


<view> {{m1.message}} </view>
```

## 2.3 wxml语法

### 2.3.1 列表渲染

```javascript
data: {
    text: "This is page data.",
    classname:"hello",
    todos:[
      {
        name:"javascript",
        completed:false
      },
      {
        name: "java",
        completed: false
      },
      {
        name: "c#",
        completed: true
      }
    ]
  },
  
  
<!--
  wx:for-item="ele"  给遍历的每一项取别名，默认名字是item
  wx:for-index="idx"  给遍历的每一项序号取别名，默认是index
  -->
  <view wx:for="{{todos}}" wx:for-item="ele" wx:for-index="idx">
     <text>{{idx}}</text>
     <text>{{ele.name}}</text>
     <checkbox checked="{{ele.completed}}"></checkbox>
  </view>
```

> ### wx:key   提高列表渲染时排序的效率

`wx:key` 的值以两种形式提供

1. 字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。

2. 保留关键字 `*this` 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字。比如数组["a","b","c"]这样的数组就可以wx:key = "*this"


### 2.3.2 条件渲染

```javascript
<!--wxml-->
<view wx:if="{{view == 'WEBVIEW'}}"> WEBVIEW </view>
<view wx:elif="{{view == 'APP'}}"> APP </view>
<view wx:else="{{view == 'MINA'}}"> MINA </view>

// page.js
Page({
  data: {
    view: 'MINA'
  }
})
```

```javascript
<!--条件渲染和for循环结合使用-->
<view wx:for="{{[1,2,3,4,5,6,7,8,9]}}"  wx:for-item="i" >
    <view wx:for="{{[1,2,3,4,5,6,7,8,9]}}"  wx:for-item="j" >
      <view wx:if="{{i<=j}}">
         {{i}}*{{j}}={{i*j}}
      </view>
    </view>
  </view>
```

```javascript
<!--block标签的使用-->
<block wx:if="{{show}}">
   <view class="content">
      <text>内容</text>
   </view>
   <view class="content">
      <text>内容</text>
   </view>
</block>

//block区块标签，不会渲染到页面。当有多个view要切换显示隐藏的时候，可以把多个view嵌套到block标签中
```

```javascript
<!--hidden属性和wx:if的区别-->
 <view class="content"   wx:if="{{show}}">
      <text>内容</text>
 </view>

 <view class="content"   hidden="{{!show}}">
      <text>内容</text>
 </view>

//wx:if 如果条件未false，则元素不会渲染到页面
//hidden: 如果条件为true，则元素会渲染到页面，只不过添加了display:none的属性让元素不显示
//频繁切换隐藏显示用hidden，不频繁切换用:if
```

### 2.3.3 模板语法

WXML提供模板（template），可以在模板中定义代码片段，然后在不同的地方调用。

```javascript
<!--声明一个名字叫staffName的模板 -->
<template name="staffName">
  <view>
    FirstName: {{firstName}}, LastName: {{lastName}}
  </view>
</template>


<!--使用模板，并且向模板传递参数-->
<template is="staffName" data="{{...staffA}}"></template>
<template is="staffName" data="{{...staffB}}"></template>
<template is="staffName" data="{{...staffC}}"></template>


// page.js
Page({
  data: {
    staffA: {firstName: 'Hulk', lastName: 'Hu'},
    staffB: {firstName: 'Shang', lastName: 'You'},
    staffC: {firstName: 'Gideon', lastName: 'Lin'}
  }
})
```

### 2.3.4 import 和 include

```
<import src="a.wxml"/>   作用可以引入目标文件中定义的template，然后在当前的wxml中使用template

<include src="header.wxml"/>  作用可以引入目标文件中除了template wxs之外的所有代码
```

## 2.4 尺寸单位和样式

   与 CSS 相比，WXSS 扩展的特性有：

- 尺寸单位(rpx  rem)
- 样式导入

### 2.4.1 尺寸单位

- rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。

  > 当设定了容器的width:750rpx之后，那么在所有的设备上宽度都是屏幕100%，微信小程序会自动帮我们做单位换算
  >

  ![img](assets\1569379659990.png)


>         **建议：** 开发微信小程序时设计师可以用 iPhone6 作为视觉稿的标准
>

- vw和vh是css3中的新单位，是一种视窗单位，在小程序中也同样适用。

> 小程序中，窗口宽度固定为100vw，将窗口宽度平均分成100份，1份是1vw
>
> 小程序中，窗口高度固定为100vh ，将窗口高度平均分成100份，1份是1vh

### 2.4.2 样式导入

使用`@import`语句可以导入外联样式表，`@import`后跟需要导入的外联样式表的相对路径，用`;`表示语句结束。

```javascript
/** common.wxss **/
.small-p {
  padding:5px;
}

/** app.wxss **/
@import "common.wxss";
.middle-p {
  padding:15px;
}
```

### 2.4.3 选择器

特别需要注意的是小程序 不支持通配符 * ，因此以下代码无效！

```
*{
    margin:0;
    padding:0;   
    box-sizing:border-box;
}
```

目前支持的选择器有：

![1576221022785](assets\1576221022785.png)

**"~"选择器**

**"+"选择器**

**[attribute]**

### 2.4.4 小程序中使用less

原声小程序不支持 less ，其他基于小程序的框架基本都支持，如 wepy ， mpvue ， taro 等。
但是仅仅因为一个less功能，而去引用框架，肯定是不可取的。因此可以使用以下方式来实现

1. 编辑器是 vscode
2. 安装插件 easy less
3. 在vs code的设置中加如下，配置

```
{
    "workbench.sideBar.location": "left",
    "less.compile": {        
      "outExt":".wxss"
    }
}
```

4. 在要编写样式的地方新建 less 文件，如 index.less ,然后正常编辑即可。

![1576221707533](assets\1576221707533.png)

## 2.5 事件

### 2.5.1 事件绑定

```javascript
  <!--
  1.绑定事件的时候不可以直接通过buttonTapHandle(123)这种方式传参，
  如果要传递参数，可以通过data-*的方式传参，可以在事件对象中的dataset中查看该参数
  2.事件处理函数中的this并不是当前触发事件的对象，而是当前的页面对象-->
  <button bindtap="buttonTapHandle" data-hi="WeChat" >点我</button>
  <!--驼峰命名法-->
  <button bindtap="buttonTapHandle" data-hello-world="WeChat" >点我</button>
   
 
  buttonTapHandle:function(e){
    console.log("tap事件",e)
  },
      
      
//普通事件函数中this是当前的页面对象
//箭头函数中的this是undefined，如果要在箭头函数中使用当前的页面对象，我们可以在onload方法中把this保持一份  
```

```javascript
//事件对象e中的信息
{
  "type":"tap",  //事件类型
  "timeStamp":895,  //事件生成时的时间戳
  //触发事件的组件的一些属性值集合
  "target": {
    "id": "tapTest",
    "dataset":  {
      "hi":"WeChat"
    }
  },
  //当前组件的一些属性值集合
  "currentTarget":  {
    "id": "tapTest",
    "dataset": {
      "hi":"WeChat"
    }
  },
  //额外的信息
  "detail": {
    "x":53,
    "y":14
  },
  //当前停留在屏幕中的触摸点信息的数组
  "touches":[{
    "identifier":0,
    "pageX":53,
    "pageY":14,
    "clientX":53,
    "clientY":14
  }],
  //当前变化的触摸点信息的数组
  "changedTouches":[{
    "identifier":0,
    "pageX":53,
    "pageY":14,
    "clientX":53,
    "clientY":14
  }]
}
```

> 注意：绑定事件时不能带参数 不能带括号 以下为错误写法
>
> ```
> <input bindinput="handleInput(100)"/>
> ```

### 2.5.2 事件冒泡

```javascript
 <!--使用bindTap绑定事件，默认会有事件冒泡-->
<view bindtap="outerHandler" style="width:200px;height:200px;background-color:red">
  <view bindtap="innerHandler" style="width:100px;height:100px;background-color:blue"></view>
</view>
 
<!--使用catchtap阻止事件冒泡-->
<view catchtap="outerHandler" style="width:200px;height:200px;background-color:red">
  <view catchtap="innerHandler" style="width:100px;height:100px;background-color:blue">   </view>
</view>
  
  
 innerHandler:function(){
    console.log("innerHandler");
  },
  outerHandler: function () {
    console.log("outerHandler");
  },
```

### 2.5.3 单向数据流

![Snipaste_2019-09-26_09-17-49](assets/Snipaste_2019-09-26_09-17-49.png)

```javascript
<!--index.wxml-->
<view class="container">
  <input value="{{message}}" bindinput="inputHandle"></input>
  <text>{{message}}</text>
</view>


inputHandle:function(e){
    //可以通过e.detail.value来获取input输入框的值
    //微信小程序采用单向数据流，input输入框的值改变之后不会触发数据源中数据的变化，如果要页面改掉之后同步更新数据，需要通过setData()方法手动触发
    console.log(e.detail.value)

    //注意：修改data数据的时候不能this.data.message=""，这样数据修改之后不会触发页面刷新

    //需要通过setData({}) 方法来修改数据，会触发页面同步更新
    this.setData({
      message:e.detail.value
    })
}
```

## 2.6 获取页面元素

<https://juejin.im/post/5be7df8ff265da61590b3169>

[节点信息查询 API](https://developers.weixin.qq.com/miniprogram/dev/api/wxml/wx.createSelectorQuery.html) 可以用于获取节点属性、样式、在界面上的位置等信息。

最常见的用法是使用这个接口来查询某个节点的当前位置，以及界面的滚动位置。

```javascript
    //创建SelectorQuery查询对象
    let query = wx.createSelectorQuery();
    //选取一个节点
    var firstDivider = query.select(".divider");
    //选取所有节点
    var dividers = query.selectAll(".divider");
    
    //获取节点的相关属性
    dividers.fields({
      id: false,//是否返回节点id
      rect: true,//是否返回节点布局位置
      dataset: true,//返回数据集
      size: true,//返回宽高
      scrollOffset: true,//返回 scrollLeft,scrollTop
      properties: ['scrollX', 'scrollY'],//只能获得组件文档中标注的常规属性值，id class style 和事件绑定的属性值不可获取
      computedStyle: ['margin', 'backgroundColor']//此处返回指定要返回的样式名
    }, function (res) {
      console.log(res,"aaa")
    })

    //添加节点的布局位置的查询请求
    dividers.boundingClientRect(function (rect) {
      console.log(rect, "bbb")
    })

    //添加节点的滚动位置查询请求
    //query.selectViewport():选择显示区域，用于获取显示区域的尺寸、滚动位置等信息
    query.selectViewport().scrollOffset(function (res) {
      console.log(res,"ccc")
    })

    //query.exec: 执行所有的请求
    query.exec(function (res) {
      //res中包含所有请求的执行结果
      console.log(res)
    })
```

## 2.7 动画

### 2.7.1 CSS动画

```javascript
<view class=""view></view>

.view {
  width: 200rpx;
  height: 200rpx;
  background-color: red;
  margin-left: 100rpx;
  margin-top: 100rpx;
  /** 第一种写法**/
  animation-name: viewlinear;
  animation-duration: 2s;
  animation-timing-function: linear;
  animation-iteration-count: infinite;
  /** 第二种写法**/
  animation: viewlinear 2s linear infinite;
}

@keyframes viewlinear {
  
  /** 第一种写法**/
  0% {
    background-color: red;
  }
  50% {
    background-color: orange;
  }
  100% {
    background-color: yellow;
  }
}
```

### 2.7.2 使用wx.createAnimation接口

<https://developers.weixin.qq.com/miniprogram/dev/api/ui/animation/wx.createAnimation.html>

```javascript
<view  animation="{{animationData}}" style="background:red;height:100rpx;width:100rpx">sss</view>


<button bindtap="scaleWidthOpcityBg">缩放宽度透明度背景色</button>
<button bindtap="rotateAndScale">旋转和缩放同时进行</button>
<button bindtap="rotateThenScale">先旋转再缩放</button>
<button bindtap="rotateAndScaleThenTranslate">先旋转再平移</button>


Page({
  data: {
    animationData: {}
  },
  scaleWidthOpcityBg: function () {
    var animation = wx.createAnimation({
      duration: 1000,
      timingFunction: "ease",
      transformOrigin: "50% 50%",
      delay: 0
    })
    //step()动画分组
    animation.scale(2, 2).width(100).opacity(0.5).backgroundColor("blue").rotate(45).step();

    this.setData({
      animationData: animation.export()
    })
  },
  rotateAndScale: function () {
    var animation = wx.createAnimation({
      duration: 1000,
      timingFunction: "ease",
      transformOrigin: "50% 50%",
      delay: 0
    })
    // 旋转同时放大
    animation.rotate(45).scale(2, 2).step()
    this.setData({
      animationData: animation.export()
    })
  },
  rotateThenScale: function () {
    var animation = wx.createAnimation({
      duration: 1000,
      timingFunction: "ease",
      transformOrigin: "50% 50%",
      delay: 0
    })
    // 先旋转后放大
    animation.rotate(45).step()
    animation.scale(2, 2).step()
    this.setData({
      animationData: animation.export()
    })
  },
  rotateAndScaleThenTranslate: function () {
    var animation = wx.createAnimation({
      duration: 1000,
      timingFunction: "ease",
      transformOrigin: "50% 50%",
      delay: 0
    })
    // 先旋转同时放大，然后平移
    animation.rotate(45).scale(2, 2).step()
    animation.translate(100, 100).step({ duration: 1000 })
    this.setData({
      animationData: animation.export()
    })
  }
})

//注意点：微信小程序createAnimation动画结束后会保留动画结束的状态
```

# 3.登陆页面案例

## 3.1 没有抽象事件处理函数

```javascript
<!-- version 1 没有抽象事件处理函数 -->
<view class="container">
  <view class="header">
    <image src="../../images/sign.png" mode="aspectFit"/>
  </view>
  <view class="inputs">
    <input class="username" placeholder="请输入用户名" value="{{ username }}" bindinput="usernameChangeHandle"/>
    <input class="password" type="password" placeholder="请输入密码" value="{{ password }}" bindinput="passwordChangeHandle"/>
  </view>
  <view class="buttons">
    <button type="primary" bindtap="loginHandle">登陆</button>
    <button type="default">注册</button>
  </view>
</view>


Page({
   data: {
     username: 'admin',
     password: '123'
   },
   usernameChangeHandle: function (e) {
     // this.data.username = e.detail.value 不要用这种方式，因为界面层无法得知
     this.setData({
       username: e.detail.value
     })
   },
   passwordChangeHandle: function (e) {
     // this.data.password = e.detail.value 不要用这种方式，因为界面层无法得知
     this.setData({
       password: e.detail.value
     })
   },
   // 用于处理登录按钮点击的事件
   loginHandle: function () {
     // TODO: 完成逻辑
     // 1. 先需要知道用户输入了什么
     console.log(this.data)
     // 2. 根据用户输入的值判断

     // 3. 根据判断的结果做出响应
  }
})



page {
  height: 100%;
}

.container {
  display: flex;
  flex-direction: column;
  height: 100%;
}

.header {
  display: flex;
  flex: 1;
  justify-content: center;
  align-items: center;
}

.header image {
  width: 200rpx;
  height: 200rpx;
}

.inputs {
  margin: 50rpx;
  padding: 10rpx 10rpx;
  border: 1rpx solid #e0e0e0;
  border-radius: 10rpx;
}

.inputs input {
  padding: 10rpx 15rpx;
}

.inputs .username {
  border-bottom: 1rpx solid #e0e0e0;
}

.buttons {
  margin: 50rpx 50rpx 100rpx 50rpx;
}

.buttons button {
  margin: 10rpx 0;
}
```

## 3.2 抽象公共的事件处理函数

```javascript
<view class="container">
  <view class="header">
    <image src="../../images/sign.png" mode="aspectFit"/>
  </view>
  <view class="inputs">
    <input 
      class="username" 
      placeholder="请输入用户名" 
      value="{{ username }}" 
      bindinput="inputChangeHandle" 
      data-prop="username"/>
    <input 
      class="password" 
      type="password" 
      placeholder="请输入密码" 
      value="{{ password }}" 
      bindinput="inputChangeHandle" 
      data-prop="password"/>
  </view>
  <view class="buttons">
    <button type="primary" bindtap="loginHandle">登陆</button>
    <button type="default">注册</button>
  </view>
</view>


 Page({
   data: {
     username: 'admin',
     password: '123'
   },
   inputChangeHandle: function (e) {
     var prop = e.target.dataset['prop']
     var changed = {}
     changed[prop] = e.detail.value

     this.setData(changed)
   },
   // 用于处理登录按钮点击的事件
   loginHandle: function () {
     // TODO: 完成逻辑
     // 1. 先需要知道用户输入了什么
     console.log(this.data)
     // 2. 根据用户输入的值判断

     // 3. 根据判断的结果做出响应
   }
 })
```

## 3.3 使用表单实现登陆

```javascript
<form bindsubmit="loginHandle">
  <view class="container">
    <view class="header">
      <image src="../../images/sign.png" mode="aspectFit"/>
    </view>
    <view class="inputs">
      <input 
        class="username" 
        name="username"
        placeholder="请输入用户名" 
        value="{{ username }}"/>
      <input 
        class="password" 
        type="password" 
        name="password"
        placeholder="请输入密码" 
        value="{{ password }}"/>
    </view>
    <view class="buttons">
      <button type="primary" form-type="submit">登陆</button>
      <button type="default">注册</button>
    </view>
  </view>
</form>


Page({
  data: {
    username: 'admin',
    password: '123'
  },
  // 用于处理表单提交事件
  loginHandle: function (e) {
    console.log(e)
  }
})
```

# 4.微信小程序组件

	在微信小程序中，不建议使用html标签，而需要使用微信小程序自己定义的组件。

![1576744927308](assets/1576744927308.png)

组件文档：https://mp.weixin.qq.com/debug/wxadoc/dev/component/

组件的分类：视图容器、基础内容、表单组件、导航组件、媒体组件、地图组件、画布组件等

## 4.1 基础内容组件

```javascript
<!--index.wxml-->
<view class="container">
    <!--1.view标签：替换原来的div-->
    <view hover-class="h-class">点击我试试</view>
    
  <!--2.text类似于HTML中的p标签-->
  <!--text主要是为了可以很好的控制页面上的内容-->
  <!--text还支持换行-->
  <text>这是一段
    <text>文本</text>
    内容
  </text>
   
  <!--长按选中文字，可对空格回车进行编码-->
  <text selectable="{{false}}" decode="{{false}}">
    普&nbsp;通 
  </text>

  <!--success, success_no_circle, info, warn, waiting, cancel, download, search, clear-->
  <!--type 用于定义图标类型，只能是规定范围的类型，除了这些内置图标，其他图标必须通过图片方式使用-->
  <icon type="success_no_circle"></icon>
  <!-- size 用于指定图标大小 默认是23 单位是px -->
  <icon type="info" size="60"></icon>
  <!-- color 用于指定图标颜色 取值就是CSS颜色取值 -->
  <icon type="info" size="60" color="red"></icon>


<!-- 显示一个进度条 -->
<!-- show-info 是用来控制是否显示具体数值的的 -->
<!--这边需要去掉container的align-items属性才能看到进度条-->
<progress percent="20" show-info />
<progress percent="40" stroke-width="12" />
<progress percent="60" color="pink" />
<!--active : 动画效果-->
<progress percent="80" active />

 <!--rich-text从1.4.0开始可以使用，低版本需要兼容，类似于vue中的v-html -->
<rich-text nodes="{{nodes}}"></rich-text>
<rich-text nodes="{{nodes1}}"></rich-text>
<rich-text nodes="{{nodes2}}"></rich-text>
</view>


 data: {
    nodes: "<h1 style='color:red;'>html标题</h1>",
    nodes1: [{
      name: "h1",
      attrs: {
        style: "color:red",
        class: "red"
      },
      children: [{
        type: "text",
        text: '结点列表标题'
      }]
    }],
    nodes2: [{
      name: "ul",
      attrs: {
        style: "padding:20px;border:1px solid blue;",
        class: "red"
      },
      children: [
        {
          name: "li",
          attrs: {
            style: "color:red",
            class: "red"
          },
          children: [{
            type: "text",
            text: '多层结点 无序列表'
          }],
        }, {
          name: "li",
          attrs: {
            style: "color:red",
            class: "red"
          },
          children: [{
            type: "text",
            text: '多层结点 无序列表1'
          }],
        }]
    }]
  },
```

![1576225843384](assets\1576225843384.png)

## 4.2 表单组件

### 4.2.1 button组件

```
  <!--1.常用按钮-->
  <!-- type是用来控制按钮的类型 只有三种：primary default warn -->
  <button type="warn">这是一个按钮</button>
  <button type="warn" size="mini" plain loading>这是一个按钮 </button>
  <!--hover 指的是按下， hover-class指的就是按下过后的作用Class-->
  <button hover-class="btn-active">hover class</button>
```

![1576223405167](assets\1576223405167.png)

```javascript
//button的常用属性
size： default/mini
type:  primary/default/warn
form-type:  submit/reset

open-type:
1.contact:打开客服会话，如果用户在会话中点击消息卡⽚后返回⼩程序，可以从bindcontact 回调中获得具体信息，具体说明
2.share：触发用户转发，使用前建议先阅读使用指引
3.getPhoneNumber：获取用户机号，可以从bindgetphonenumber回调中获取到用户信息
4.getUserInfo：获取用户信息，可以从bindgetuserinfo回调中获取到用户信息
5.launchApp：打开APP，可以通过app-parameter属性设定向APP传的参数具体说明
6.openSetting：打开授权设置页
7.feedback：打开“意见反馈”，用户提交反馈内容并上传日志，开发者可以登录小程序管理后台后进入左侧菜单“客服反馈”页面获取到反馈内容
```

### 4.2.2 常用表单组件

```javascript
<!--1.form表单，可以绑定提交事件和重置表单事件-->
<form bindsubmit="formSubmit" bindreset="formReset">
  <!--2.switch-->
  <view class="section section_gap">
    <view class="section__title">switch</view>
    <switch name="switch" />
  </view>

  <!--3.slider-->
  <view class="section section_gap">
    <view class="section__title">slider</view>
    <slider name="slider" show-value></slider>
  </view>

  <!--4.输入框-->
  <view class="section">
    <view class="section__title">input</view>
	<!--
	   微信小程序中的input的type值只有下面四种：
        text	文本输入键盘	
        number	数字输入键盘	
        idcard	身份证输入键盘	
        digit	带小数点的数字键盘
     -->
    <input name="input" placeholder="please input here" />
  </view>

  <!--5.radio-->
  <view class="section section_gap">
    <view class="section__title">radio</view>
    <radio-group name="radio-group" bindchange="radioChange">
      <label>
        <radio value="radio1" />radio1</label>
      <label>
        <radio value="radio2" />radio2</label>
    </radio-group>
  </view>

  <!--6.checkbox    checkbox-group可以绑定change事件-->
  <view class="section section_gap">
    <view class="section__title">checkbox</view>
    <checkbox-group name="checkbox" bindchange="checkboxChange">
      <label>
        <checkbox value="checkbox1" />checkbox1</label>
      <label>
        <checkbox value="checkbox2" />checkbox2</label>
    </checkbox-group>
  </view>

  <!--7.textarea-->
  <view class="section">
    <textarea bindblur="bindTextAreaBlur" auto-height placeholder="自动变高" />
  </view>

  <!--8.提交表单按钮-->
  <view class="btn-area">
    <button formType="submit">Submit</button>
    <button formType="reset">Reset</button>
  </view>
</form>


//index.js
Page({
  data: {},
  checkboxChange: function(e) {
    console.log('checkbox发生change事件，携带value值为：', e.detail.value)
  },
  onLoad: function(options) {
    // 页面创建时执行
  }
})
```

### 4.2.3 picker

```javascript
<view class="container">
  <!--1.普通选择器-->
  <view class="section">
    <view class="section__title">普通选择器</view>
    <picker bindchange="bindPickerChange" value="{{index}}" range="{{array}}">
      <view class="picker">
        当前选择：{{array[index]}}
      </view>
    </picker>
  </view>

  <!--2.多列选择器-->
  <view class="section">
    <view class="section__title">多列选择器</view>
    <picker mode="multiSelector" bindchange="bindMultiPickerChange" bindcolumnchange="bindMultiPickerColumnChange" value="{{multiIndex}}" range="{{multiArray}}">
      <view class="picker">
        当前选择：{{multiArray[0][multiIndex[0]]}}，{{multiArray[1][multiIndex[1]]}}
      </view>
    </picker>
  </view>


  <!--3.时间选择器-->
  <view class="section">
    <view class="section__title">时间选择器</view>
    <picker mode="time" value="{{time}}" start="09:01" end="21:01" bindchange="bindTimeChange">
      <view class="picker">
        当前选择: {{time}}
      </view>
    </picker>
  </view>

  <!--4.日期选择器-->
  <view class="section">
    <view class="section__title">日期选择器</view>
    <picker mode="date" value="{{date}}" start="2015-09-01" end="2017-09-01" bindchange="bindDateChange">
      <view class="picker">
        当前选择: {{date}}
      </view>
    </picker>
  </view>

  <!--5.省市区选择器-->
  <view class="section">
    <view class="section__title">省市区选择器</view>
    <!--mode 为region会自动切换数据-->
    <picker mode="region" bindchange="bindRegionChange" value="{{region}}" custom-item="{{customItem}}">
      <view class="picker">
        当前选择：{{region[0]}}，{{region[1]}}，{{region[2]}}
      </view>
    </picker>
  </view>

</view>


//index.js
Page({
  data: {
    //普通选择器的数据源
    array: ['美国', '中国', '巴西', '日本'],
    index: 0,

    //多列选择器的数据源
    multiArray: [['无脊柱动物', '脊柱动物'], ['扁性动物', '线形动物', '环节动物', '软体动物', '节肢动物']],
    multiIndex: [0, 0],

    //时间选择器数据源
    time: '12:01',

    //日期选择器数据源
    date: '2016-09-01',
   
    //日期选择器数据
    region: ['广东省', '广州市', '海珠区'],
    customItem: '全部'
  },
  //普通选择器点击确认触发事件
  bindPickerChange: function (e) {
    console.log('picker发送选择改变，携带值为', e.detail.value)
    this.setData({
      index: e.detail.value
    })
  },

  //多列选择器点击确认触发事件
  bindMultiPickerChange: function (e) {
    console.log('picker发送选择改变，携带值为', e.detail.value)
    this.setData({
      multiIndex: e.detail.value
    })
  },
//多列选择器某列发生改变触发事件
  bindMultiPickerColumnChange: function (e) {
    console.log('修改的列为', e.detail.column, '，值为', e.detail.value);
    //当选择的列发生改变之后会触发数据源发生变化(所以将原来的数据源复制一份)
    var data = {
      multiArray: this.data.multiArray,
      multiIndex: this.data.multiIndex
    };
    //根据用户选择的列修改multiIndex
    data.multiIndex[e.detail.column] = e.detail.value;
    //判断当前选择的列是第几列
    switch (e.detail.column) {
      //如果用户选择的是第0列，则需要修改数据源multiArray中第1条数据
      case 0:
        switch (data.multiIndex[0]) {
          //当用户选择了第0列的第0条数据
          case 0:
            data.multiArray[1] = ['扁性动物', '线形动物', '环节动物', '软体动物', '节肢动物'];
            break;
            //当用户选择了第0列的第1条数据
          case 1:
            data.multiArray[1] = ['鱼', '两栖动物', '爬行动物'];
            break;
        }
        //让multiIndex中的第1列和第2列默认选择第0条数据
        data.multiIndex[1] = 0;
        break;
      //如果用户修改的是第1列，无需做其他什么
      case 1:
        break;
    }
    console.log(data.multiIndex);
    this.setData(data);
  },

 //日期选择器事件
  bindDateChange: function (e) {
    console.log('picker发送选择改变，携带值为', e.detail.value)
    this.setData({
      date: e.detail.value
    })
  },

  //时间选择器事件
  bindTimeChange: function (e) {
    console.log('picker发送选择改变，携带值为', e.detail.value)
    this.setData({
      time: e.detail.value
    })
  },

  //日期选择器
  bindRegionChange: function (e) {
    console.log('picker发送选择改变，携带值为', e.detail.value)
    this.setData({
      region: e.detail.value
    })
  }
})
```

## 4.3 交互组件

https://developers.weixin.qq.com/miniprogram/dev/api/ui/interaction/wx.showToast.html

```javascript
<view class="container">
  <button type="primary" bindtap="btnToDo">click me....</button>
</view>


Page({
  data: {
  },
  btnToDo: function () {
    // 当点击按钮触发
    console.log(1111)
   // 交互操作组件 必须通过调用API方式使用
    // wx.showActionSheet({
    //   // 显示出来的项目列表
    //   itemList: ["新增","删除","修改"],
    //   // 点击其中任一项的回调
    //   success: function (res) {
    //     // res.cancel 指的是是否点击了取消
    //     if (!res.cancel) {
    //       // tapIndex指的是点击的下标
    //       console.log(res.tapIndex)
    //     }
    //   }
    // })

    // wx.showModal({
    //   title: '提示',
    //   content: '这是一个模态弹窗',
    //   success: function(res) {
    //     if (res.confirm) {
    //       console.log('用户点击确定')
    //     }
    //   }
    // })

    wx.showToast({
      title: '成功',
      // 只支持 success 和 loading
      icon: 'loading',
      duration: 2000
    })
  }
})
```

## 4.4 媒体组件

### 4.4.1 image

```javascript
<image src="/assets/images/zcs65a.jpg" lazy-load></image>
/*这边设置src路径的时候不需要使用相对路径，/本身代表项目根路径  */

.container image{
  width: 750rpx;
  /*rpx单位：参照设计稿尺寸，如果设计稿以iphone6屏幕为基准
     iphone6 屏幕大小是375*667

     图片大小是750*1124px，则可以设置图片宽高为
     width:750rpx;
     height:1124rpx;

     iphone5  1rpx = 0.42px
     iphone6 1rpx = 0.5px
     iphone6plus 1rpx = 0.552px

     实际开发中，只需要参照设计稿去设置rpx的值就可以，不需要再额外考虑屏幕的适配
  */
  height: 1124rpx;
  /* height: 562px; */
}

注意：
1.image组件默认宽度300px、高度225px，很多时候我们都不需要这个默认宽高，记得手动设置宽高
2.微信小程序的图片是支持 lazy-load
3.mode 有 13 种模式，其中 4 种是缩放模式，9种是裁剪模式。


aspectFit和widthFix区别：
1.aspectFit：保持图片宽高比例，让长边完全显示出来，但是图片如果没有设置过宽高，还是原来默认的宽高
2.widthFix：图片宽度填充，高度由图片宽高比自动计算。
```

![1576222641112](assets\1576222641112.png)

### 4.4.2 audio

```javascript
<!-- audio.wxml -->
<audio poster="{{poster}}" name="{{name}}" author="{{author}}" src="{{src}}" id="myAudio" controls loop></audio>

<button type="primary" bindtap="audioPlay">播放</button>
<button type="primary" bindtap="audioPause">暂停</button>
<button type="primary" bindtap="audio14">设置当前播放时间为14秒</button>
<button type="primary" bindtap="audioStart">回到开头</button>


// audio.js
Page({
  onReady: function (e) {
    // 使用 wx.createAudioContext 获取 audio 上下文 context
    this.audioCtx = wx.createAudioContext('myAudio')
  },
  data: {
    poster: 'http://y.gtimg.cn/music/photo_new/T002R300x300M000003rsKF44GyaSk.jpg?max_age=2592000',
    name: '此时此刻',
    author: '许巍',
    src: 'http://ws.stream.qqmusic.qq.com/M500001VfvsJ21xFqb.mp3?guid=ffffffff82def4af4b12b3cd9337d5e7&uin=346897220&vkey=6292F51E1E384E06DCBDC9AB7C49FD713D632D313AC4858BACB8DDD29067D3C601481D36E62053BF8DFEAF74C0A5CCFADD6471160CAF3E6A&fromtag=46',
  },
  audioPlay: function () {
    this.audioCtx.play()
  },
  audioPause: function () {
    this.audioCtx.pause()
  },
  audio14: function () {
    this.audioCtx.seek(14)
  },
  audioStart: function () {
    this.audioCtx.seek(0)
  }
})
```

### 4.4.3 camera

```javascript
<!-- camera.wxml -->
<camera device-position="back" flash="off" binderror="error" style="width: 100%; height: 300px;"></camera>
<button type="primary" bindtap="takePhoto">拍照</button>
<view>预览</view>
<image mode="widthFix" src="{{src}}"></image>


Page({
  takePhoto() {
    const ctx = wx.createCameraContext()
    ctx.takePhoto({
      quality: 'high',
      success: (res) => {
        this.setData({
          src: res.tempImagePath
        })
      }
    })
  },
  error(e) {
    console.log(e.detail)
  }
})
```

### 4.4.4 vedio组件

```javascript
<view class="section tc">
  <video id="myVideo" src="http://wxsnsdy.tc.qq.com/105/20210/snsdyvideodownload?filekey=30280201010421301f0201690402534804102ca905ce620b1241b726bc41dcff44e00204012882540400&bizid=1023&hy=SH&fileparam=302c020101042530230204136ffd93020457e3c4ff02024ef202031e8d7f02030f42400204045a320a0201000400" danmu-list="{{danmuList}}" enable-danmu danmu-btn controls></video>
</view>

Page({
  onReady: function (res) {
    this.videoContext = wx.createVideoContext('myVideo')
  },
  inputValue: '',
  data: {
    src: '',
    danmuList: [
      {
        text: '第 1s 出现的弹幕',
        color: '#ff0000',
        time: 1
      },
      {
        text: '第 3s 出现的弹幕',
        color: '#ff00ff',
        time: 3
      }]
  }
})
```

## 4.5 常用布局标签

### 4.5.1 scroll-view

```xml
<view>
  <!--垂直滚动，这里必须设置高度-->
  <scroll-view scroll-y="{{true}}" style="height: 200px">
    <view style="background: red; width: 100px; height: 100px"></view>
    <view style="background: green; width: 100px; height: 100px"></view>
    <view style="background: blue; width: 100px; height: 100px"></view>
    <view style="background: yellow; width: 100px; height: 100px"></view>
  </scroll-view>

  <!--  white-space
  normal: 正常无变化(默认处理方式.文本自动处理换行.假如抵达容器边界内容会转到下一行)
  pre: 保持HTML源代码的空格与换行,等同与pre标签
  nowrap: 强制文本在一行,除非遇到br换行标签
  pre-wrap: 同pre属性,但是遇到超出容器范围的时候会自动换行
  pre-line: 同pre属性,但是遇到连续空格会被看作一个空格
  inherit: 继承
-->
  <!--水平滚动-->
  <scroll-view scroll-x="{{true}}" style=" white-space: nowrap;">
    <view style="background: red; width: 200px; height: 100px; display: inline-block"></view>
    <view style="background: green; width: 200px; height: 100px; display: inline-block"></view>
    <view style="background: blue; width: 200px; height: 100px; display: inline-block"></view>
    <view style="background: yellow; width: 200px; height: 100px; display: inline-block"></view>
  </scroll-view>
</view>


注意点：scroll-y="{{true}}" 和scroll-y="true"的区别：
scroll-y="{{true}}" 设置值为true
scroll-y="true"      设置值为字符串"true"，结果仍然为true
scroll-y="false"      设置值为字符串"false"，结果仍然为true
```

### 4.5.2 swiper

```javascript
<view>
   <!--circular:true  循环轮播
       swiper组件会有一个默认高度是150px
       -->
  <swiper indicator-dots="{{indicatorDots}}" autoplay="{{autoplay}}" interval="{{interval}}" duration="{{duration}}" circular="{{true}}">
    <block wx:for="{{imgUrls}}">
      <swiper-item>
        <!--widthFix:保持图片宽高比不变-->
        <image src="{{item}}" class="slide-image" mode="widthFix" />
      </swiper-item>
    </block>
  </swiper>
</view>


Page({
  data: {
    imgUrls: [
      'https://images.unsplash.com/photo-1551334787-21e6bd3ab135?w=640',
      'https://images.unsplash.com/photo-1551214012-84f95e060dee?w=640',
      'https://images.unsplash.com/photo-1551446591-142875a901a1?w=640'
    ],
    indicatorDots: true,
    autoplay: true,
    interval: 5000,
    duration: 1000
  }
})


//图片宽高是：640*427
//swiper默认高度是150px，如果不该swiper的高度，那么当屏幕变大后，图片由于100%宽度会拉升，而高度拉升部分会被父亲swiper挡住。因此这边要修改swiper的高度
.slide-image{
      width:100%;
}
swiper{
    width:750rpx;
    height:500rpx;    //  750*427/640
}
```

![1576222939456](assets\1576222939456.png)

## 4.6 地图组件

```javascript
  <map id="map" longitude="{{longitude}}" latitude="{{latitude}}" scale="{{scale}}" controls="{{controls}}" bindcontroltap="controltap" markers="{{markers}}" circles="{{circles}}" bindmarkertap="markertap" polyline="{{polyline}}" bindregionchange="regionchange" show-location style="width: 100%; height: {{view.Height}}px;"></map>

//app.json中添加定位权限
 "permission": {
    "scope.userLocation": {
      "desc": "你的位置信息将用于小程序位置接口的效果展示"
    }
  }


Page({
  data: {
    Height: 0,
    //缩放比例
    scale: 13,
    //经纬度
    latitude: "",
    longitude: "",
    //地图上的标记
    markers: [],
    //地图上显示的控件
    controls: [{
      id: 1,
      iconPath: '../../assets/tabs/profile.png',
      position: {
        left: 320,
        top: 100 - 50,
        width: 20,
        height: 20
      },
      clickable: true
    },
    {
      id: 2,
      iconPath: '/assets/tabs/message.png',
      position: {
        left: 340,
        top: 100 - 50,
        width: 20,
        height: 20
      },
      clickable: true
    }
    ],
    circles: []

  },

  onLoad: function () {
    var _this = this;

    wx.getSystemInfo({
      success: function (res) {
        //设置map高度，根据当前设备宽高满屏显示
        _this.setData({
          view: {
            Height: res.windowHeight
          }

        })

      }
    })

    wx.getLocation({
      type: 'wgs84', // 默认为 wgs84 返回 gps 坐标，gcj02 返回可用于 wx.openLocation 的坐标
                     //WGS-84：GPS坐标系
					 //GCJ-02：火星坐标系，国测局02年发布的坐标体系，高德，腾讯等使用。
					 //BD-09：百度坐标系，百度自研，百度地图使用。
      success: function (res) {

        _this.setData({
          latitude: res.latitude,
          longitude: res.longitude,
          markers: [{
            id: "1",
            latitude: res.latitude,
            longitude: res.longitude,
            width: 50,
            height: 50,
            iconPath: "/assets/tabs/home.png",
            title: "哪里"
          }],
          circles: [{
            latitude: res.latitude,
            longitude: res.longitude,
            color: '#FF0000DD',
            fillColor: '#7cb5ec88',
            radius: 3000,
            strokeWidth: 1
          }]

        })
      }

    })

  },

  regionchange(e) {
    console.log("regionchange===" + e.type)
  },

  //点击merkers
  markertap(e) {
    console.log(e.markerId)

    wx.showActionSheet({
      itemList: ["A"],
      success: function (res) {
        console.log(res.tapIndex)
      },
      fail: function (res) {
        console.log(res.errMsg)
      }
    })
  },

  //点击缩放按钮动态请求数据
  controltap(e) {
    var that = this;
    console.log("scale===" + this.data.scale)
    if (e.controlId === 1) {
      // if (this.data.scale === 13) {
      that.setData({
        scale: --this.data.scale
      })
      // }
    } else {
      //  if (this.data.scale !== 13) {
      that.setData({
        scale: ++this.data.scale
      })
      // }
    }
  },
})
```

## 4.7 画布

<https://developers.weixin.qq.com/miniprogram/dev/framework/ability/canvas.html>

```javascript
<!-- canvas.wxml -->
<canvas style="width: 300px; height: 200px;" canvas-id="firstCanvas"></canvas>

Page({
  onReady: function (e) {
    // 使用 wx.createContext 获取绘图上下文 context
    var context = wx.createCanvasContext('firstCanvas')

    context.setStrokeStyle("#00ff00")
    context.setLineWidth(5)
    context.rect(0, 0, 200, 200)
    context.stroke()
    context.setStrokeStyle("#ff0000")
    context.setLineWidth(2)
    context.moveTo(160, 100)
    context.arc(100, 100, 60, 0, 2 * Math.PI, true)
    context.moveTo(140, 100)
    context.arc(100, 100, 40, 0, Math.PI, false)
    context.moveTo(85, 80)
    context.arc(80, 80, 5, 0, 2 * Math.PI, true)
    context.moveTo(125, 80)
    context.arc(120, 80, 5, 0, 2 * Math.PI, true)
    context.stroke()
    context.draw()
  }
})
```

## 4.8 flex布局

### 4.8.1 flex简介

在微信小程序中， [view](https://developers.weixin.qq.com/miniprogram/dev/component/view.html)是最基础的布局容器，其支持两种布局方式`block`、`flex`，默认情况下，[view](https://developers.weixin.qq.com/miniprogram/dev/component/view.html)的布局方式是`block`，如下所示：

```
<view>
    <view style='background:red;'>1</view>
    <view style='background:blue;'>2</view>
    <view style='background:yellow;'>3</view>
</view>
```

![1569552921995](assets\1569552921995.png)

	微信小程序经常使用flex布局。
	
	以前在网页开发过程中，布局一直是不可或缺的，从最早的表格布局，到后来的DIV+CSS布局，现在再到CSS3的伸缩布局。
	
	CSS3在布局方面做了非常大的改进，使得我们对块级元素的布局排列变得十分灵活，适应性非常强，其强大的伸缩性，在响应式开中可以发挥极大的作用。

> 参考链接：https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex

**主轴：**Flex容器的主轴主要用来配置Flex项目，默认是水平方向

**侧轴：**与主轴垂直的轴称作侧轴，默认是垂直方向的

**方向：**默认主轴从左向右，侧轴默认从上到下

_主轴和侧轴并不是固定不变的，通过flex-direction可以互换。_          

### 4.8.2 flex使用说明

1. 指定一个父盒子为伸缩盒子，即指定：`display: flex`
2. 明确你需要的主侧轴方向，并设置`flex-direction` 默认是row ，纵向是column
3. 设置父盒子的属性来调整子元素的布局，例如`align-items`
4. 设置子盒子的宽高或者比例，完成具体的子元素在父盒子中的布局

### 4.8.3 flex各个属性介绍

1. `flex-direction`调整主轴方向（默认为水平方向）

2. `justify-content`调整主轴对齐

3. `align-items`调整侧轴对齐（子元素可以使用`align-self`覆盖）

4. `flex-wrap`控制是否换行

5. `align-content`堆栈（由flex-wrap产生的独立行）对齐

6. `flex-flow`是`flex-direction` + `flex-wrap`的简写形式

7. `flex`是子项目在主轴的缩放比例，不指定flex属性，则不参与伸缩分配

   ```
   flex 是 flex-grow、flex-shrink、flex-basis的缩写。
   该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)

   .item {flex: 2;}
   /*等效于*/
   .item {
       flex-grow: 2;
       flex-shrink: 1;
       flex-basis: 0%;  
   }

   flex-basis属性作用：用于设置子元素的宽度，如果写了这个属性会替换掉width属性值。

   flex-basis:0/0%;   设置子元素的宽度为0px(不占用宽度，此时flex-grow会生效)
   flex-basis:auto;   在确定子元素宽度的时候首先会去参考子元素的width属性值，在没有设置width属性的宽度的情况下会参照元素的content的宽度
   ```

8. `order`控制子项目的排列顺序，正序方式排序，从小到大

_此知识点重在理解，要明确找出主轴、侧轴、方向，各属性对应的属性值可参考示例源码。_

## 4.9 cloud music的flex布局案例

### 4.9.1 导航栏颜色

```javascript
//pages/index/index.json
{
    "navigationBarTitleText": "Music Player",
    "navigationBarBackgroundColor": "#333",
    "navigationBarTextStyle": "white"
}
```

### 4.9.2 首页结构划分

```javascript
<view class="root">
  <!-- 标签栏的页签 固定高度 -->
  <view class="tabs">
   
  </view>
  <!-- 内容区域 自适应高度 -->
  <scroll-view class="content" scroll-y>
   
  </scroll-view>
  <!-- 播放控制条 固定高度 -->
  <view class="player">
   
  </view>
</view>



page {
  height: 100%;
}

.root {
  display: flex;
  flex-direction: column;
  height: 100%;
  background-color: #f0f0f0;
}

.tabs{
  height: 100rpx;
  background-color: red;
}

.content{
  flex: 1;
  background-color: yellow;
}

.player{
  height: 100rpx;
  background-color: blue;
}
```

### 4.9.3 首页标签栏

```javascript
  <!-- 标签栏的页签 固定高度 -->
  <view class="tabs">
    <view class="item active">
      <text>个性推荐</text>
    </view>
    <view class="item">
      <text>歌单</text>
    </view>
    <view class="item">
      <text>主播电台</text>
    </view>
    <view class="item">
      <text>排行榜</text>
    </view>
  </view>
  
  
  
.tabs{
  /* height: 100rpx; */
  background-color: red;
  display: flex;
}

.tabs .item {
  flex: 1;
  text-align: center;
  font-size: 12px;
  background-color: #222;
  color: #ccc;
  padding: 8px 0;
}

.tabs .item.active {
  color: #fff;
  border-bottom: 2px solid #e9232c;
}
```

### 4.9.4 播放栏

```javascript
  <!-- 播放控制条条 固定高度 -->
  <view class="player">
   <view class="poster">
      <image src="../../images/poster.jpg"></image>
    </view>
    <view class="info">
      <text class="title">一生中最爱</text>
      <text class="artist">谭咏麟</text>
    </view>
    <view class="controls">
      <image src="../../images/01.png"></image>
      <image src="../../images/02.png"></image>
      <image src="../../images/03.png"></image>
    </view>
  </view>
  
  
  
/*player样式*/
.player{
  height: 100rpx;
  background-color:#17181A;
  display: flex;
}

.poster image {
  width: 40px;
  height: 40px;
  margin: 5px;
}

.info {
  flex: 1;
  color: #888;
  font-size: 14px;
  margin: 5px;
}

.info .title{
  display: block;
  font-size: 16px;
  color: #ccc;
}

.controls image {
  width: 40px;
  height: 40px;
  margin: 5px 2px;
}
```

### 4.9.5 内容栏

```javascript
  <!-- 内容区域 自适应高度 -->
  <scroll-view class="content" scroll-y>
     <!--1.图片轮播-->
    <swiper class="slide" autoplay indicator-dots>
      <swiper-item>
        <image src="../../images/slide.png"></image>
      </swiper-item>
      <swiper-item>
        <image src="../../images/slide.png"></image>
      </swiper-item>
      <swiper-item>
        <image src="../../images/slide.png"></image>
      </swiper-item>
    </swiper>
      <!--2.模块入口-->
    <view class="portals">
      <view class="item">
        <image src="../../images/04.png"></image>
        <text>私人FM</text>
      </view>
      <view class="item">
        <image src="../../images/05.png"></image>
        <text>每日歌曲推荐</text>
      </view>
      <view class="item">
        <image src="../../images/06.png"></image>
        <text>云音乐新歌榜</text>
      </view>
    </view>
    <!--3.推荐歌单-->
    <view class="list">
      <view class="title">
        <text>推荐歌单</text>
      </view>
      <view class="inner">
        <view class="item">
          <image src="../../images/poster.jpg"></image>
          <text>一生中最爱的是谁谁？</text>
        </view>
        <view class="item">
          <image src="../../images/poster.jpg"></image>
          <text>一生中最爱的是谁谁？</text>
        </view>
        <view class="item">
          <image src="../../images/poster.jpg"></image>
          <text>一生中最爱的是谁谁？</text>
        </view>
        <view class="item">
          <image src="../../images/poster.jpg"></image>
          <text>一生中最爱的是谁谁？</text>
        </view>
        <view class="item">
          <image src="../../images/poster.jpg"></image>
          <text>一生中最爱的是谁谁？</text>
        </view>
        <view class="item">
          <image src="../../images/poster.jpg"></image>
          <text>一生中最爱的是谁谁？</text>
        </view>
      </view>
    </view>
  </scroll-view>



.content{
  flex: 1;
  background-color: yellow;
  overflow: hidden;  /*超出范围隐藏*/
}

.slide image {
  width: 100%;
  height: 260rpx;
}

/*portals 开启flex布局*/
.portals {
  display: flex;
  margin-bottom: 30rpx;
}

.portals .item {
  flex: 1;
}

.portals .item image {
  width: 120rpx;
  height: 120rpx;
  /*图片改成块级元素后可以设置margin:0 auto设置居中*/
  display: block;
  margin: 20rpx auto;
}

.portals .item text {
  display: block;  /*text默认是行内元素，把他转换成块级元素再设置居中就可以*/
  font-size: 24rpx;
  text-align: center;
}

.list .title {
  margin: 10rpx 20rpx;
  font-size: 28rpx;
}

.list .inner {
  display: flex;
  flex-wrap: wrap;
}


.list .inner .item {
  width: 33.33333333%;
}

.list .inner .item image {
  display: block;
  width: 240rpx;
  height: 240rpx;
  margin: 0 auto;
}

.list .inner .item text {
  font-size: 28rpx;
}
```

# 5.自定义组件

## 5.1 自定义组件的基本步骤

![1576226443920](assets\1576226443920.png)

```javascript
//1.pages下新建components文件夹
//2.components文件夹下新建一个文件夹Tabs
//3.Tabs下新tabs.js   tabs.json   tabs.wxml   tabs.wxss
//4.tabs.json
    {
      //声明组件
      "component": true, 
      "usingComponents": { 
      }
    }
    
//5.tabs.wxml
<view class="tabs">
  <view class="tabs_title">
    <!-- <view class="title_item active">首页</view>
    <view class="title_item">原创</view>
    <view class="title_item">分类</view>
    <view class="title_item">关于</view> -->

    <view 
    wx:for="{{tabs}}"
    wx:key="id"
    class="title_item {{item.isActive?'active':''}}"
    bindtap="hanldeItemTap"
    data-index="{{index}}"
    >
    {{item.name}}
  </view>
  </view>
  <view class="tabs_content">
    <!-- 
      slot 标签 其实就是一个占位符 插槽
      等到 父组件调用 子组件的时候 再传递 标签过来 最终 这些被传递的标签
      就会替换 slot 插槽的位置 
     -->
    <slot></slot>
  </view>
</view>

//6.tabs.wxss
.tabs{}
.tabs_title{
  display: flex;
  padding: 10rpx 0;
}
.title_item{
  flex: 1;
  display: flex;
  justify-content: center;
  align-items: center;
}
.active{
  color:red;
  border-bottom: 5rpx solid currentColor;
}
.tabs_content{}

//7.tabs.js
// components/Tabs.js
Component({
  /**
   * 里面存放的是 要从父组件中接收的数据
   */
  properties: {
    // 要接收的数据的名称
    // aaa:{
    //   // type  要接收的数据的类型 
    //   type:String,
    //   // value  默认值
    //   value:""
    // }
    tabs:{
      type:Array,
      value:[]
    }
  },

  /**
   * 组件的初始数据
   */
  data: {
    // tabs
  },
  /* 
  1 页面.js 文件中 存放事件回调函数的时候 存放在data同层级下！！！
  2 组件.js 文件中 存放事件回调函数的时候 必须要存在在 methods中！！！
   */
 

  methods: {
    hanldeItemTap(e){
      /* 
      1 绑定点击事件  需要在methods中绑定
      2 获取被点击的索引 
      3 获取原数组 
      4 对数组循环
        1 给每一个循环性 选中属性 改为 false
        2 给 当前的索引的 项 添加激活选中效果就可以了！！！

       
       5 点击事件触发的时候 
          触发父组件中的自定义事件 同时传递数据给  父组件  
          this.triggerEvent("父组件自定义事件的名称",要传递的参数)
       */

      //  2 获取索引
      const {index}=e.currentTarget.dataset;
      // 5 触发父组件中的自定义事件 同时传递数据给  
      this.triggerEvent("itemChange",{index});
      // 3 获取data中的数组
      // 解构  对 复杂类型进行结构的时候 复制了一份 变量的引用而已
      // 最严谨的做法 重新拷贝一份 数组，再对这个数组的备份进行处理，
      // let tabs=JSON.parse(JSON.stringify(this.data.tabs));
      // 不要直接修改 this.data.数据 
      // let {tabs}=this.data;
      // let tabs=this.data;
      // 4 循环数组
      // [].forEach 遍历数组 遍历数组的时候 修改了 v ，也会导致源数组被修改
      // tabs.forEach((v,i)=>i===index?v.isActive=true:v.isActive=false);

      // this.setData({
        // tabs
      // })
    }
  }
})
```

## 5.2 使用自定义组件

```javascript
//1.index.json
{
  "usingComponents": {
    "Tabs":"../../components/Tabs/Tabs"
  }
}

//2.index.wxml
<!-- 
  1 父组件(页面) 向子组件 传递数据 通过 标签属性的方式来传递
    1 在子组件上进行接收
    2 把这个数据当成是data中的数据直接用即可
  2 子向父传递数据 通过事件的方式传递
    1 在子组件的标签上加入一个 自定义事件
  
 -->
<Tabs tabs="{{tabs}}" binditemChange="handleItemChange" >

<block wx:if="{{tabs[0].isActive}}">0 </block>
<block wx:elif="{{tabs[1].isActive}}">1 </block>
<block wx:elif="{{tabs[2].isActive}}">2 </block>
<block wx:else>3</block>
</Tabs>

//3.index.js
// pages/demo17/demo18.js
Page({

  /**
   * 页面的初始数据
   */
  data: {

    tabs: [
      {
        id: 0,
        name: "首页",
        isActive: true
      },
      {
        id: 1,
        name: "原创",
        isActive: false
      }
      ,
      {
        id: 2,
        name: "分类",
        isActive: false
      }
      ,
      {
        id: 3,
        name: "关于",
        isActive: false
      }
    ]

  },

  // 自定义事件 用来接收子组件传递的数据的
  handleItemChange(e) {
    // 接收传递过来的参数
    const { index } = e.detail;
    let { tabs } = this.data;
    tabs.forEach((v, i) => i === index ? v.isActive = true : v.isActive = false);
    this.setData({
      tabs
    })
  }
})
```

## 5.3 父子组件的通信

### 5.3.1 父传子

```javascript
// 在子组件中声明properties
Component({
  properties: {
    tabs:{
      type:Array,
      value:[]
    }
  },
}
// 父组件在使用子组件的时候给子组件传递数据
<Tabs tabs="{{tabs}}"></Tabs>
```

### 5.3.2 子传父

```javascript
//父组件在使用子组件的时候给子组件传递事件
<Tabs tabs="{{tabs}}" binditemChange="handleItemChange"></Tabs>

//在子组件的点击方法中触发父组件传递过来的事件
<view wx:for="{{tabs}}" class="title_item {{item.isActive?'active':''}}" wx:for-index="index" wx:key="item.id" wx:for-item="item" bindtap="hanldeItemTap" data-index="{{index}}">

hanldeItemTap(e){
    var index = e.currentTarget.dataset.index;
    //在孩子中触发父亲传递过来的事件
    this.triggerEvent("itemChange",{index});
}
```

## 5.4 组件的生命周期

<https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/lifetimes.html>

	组件的生命周期，指的是组件自身的一些函数，这些函数在特殊的时间点或遇到一些特殊的框架事件时被自动触发。其中，最重要的生命周期是 `created` `attached` `detached` ，包含一个组件实例生命流程的最主要时间点

```javascript
// components/Dialog/dialog.js
Component({
  //组件的生命周期
  lifetimes: {
    created:function(){
      //在组件实例刚刚被创建时执行
      console.log("created")
    },
    attached: function () {
      // 在组件实例进入页面节点树时执行
      console.log("attached")
    },
    detached: function () {
      // 在组件实例被从页面节点树移除时执行
      console.log("detached")
    }
  }
})
```

![1576227711864](assets\1576227711864.png)

## 5.5 组件数据监听

	数据监听器可以用于监听和响应任何属性和数据字段的变化。类似于vue的watch

```javascript
Component({
  data:{
      numberA: 1,
      numberB: 2,
  },
  observers: {
    'numberA, numberB': function(numberA, numberB) {
      // 在 numberA 或者 numberB 被设置时，执行这个函数
      this.setData({
        sum: numberA + numberB
      })
    },
    /*监听所有数据的变化*/
     '**': function() {
      // 每次 setData 都触发
    },
  }
})
```

## 5.6 常用第三方组件库

### 5.6.1 组件库介绍

```javascript
1.WeUI WXSS ： WeUI WXSS是腾讯官方UI组件库WeUI的小程序版，提供了跟微信界面风格一致的用户体验。
   GitHub地址：https://github.com/Tencent/weui-wxss npm下载：npm i weui-wxss

2.iView WeApp：iView是TalkingData发布的一款高质量的基于Vue.js组件库，而iView weapp则是它们的小程序版本。
   GitHub地址：https://github.com/TalkingData/iview-weapp npm下载：npm i iview-weapp

3.ZanUI WeApp：ZanUI WeApp是有赞移动 Web UI 规范 ZanUI 的小程序实现版本，结合了微信的视觉规范，为用户提供更加统一的使用感受。现已包含 badge、btn、card、cell、dialog、icon、label、noticebar、panel、popup、switch、tab、toast、tooltips 等组件或元素。
   GitHub地址：https://github.com/youzan/zanui-weapp npm下载：npm i zanui-weapp
   另外，ZanUI也使用mpvue重写了zanui-weapp，实现了其中所有组件，为使用mpvue的开发者提供了方便。
   GitHub地址：https://github.com/samwang1027/mpvue-zanui npm下载：npm i mpvue-zanui

4.MinUI ：MinUI 是蘑菇街前端开发团队开发的基于微信小程序自定义组件特性开发而成的一套简洁、易用、高效的组件库，适用场景广，覆盖小程序原生框架，各种小程序组件主流框架等，并且提供了专门的命令行工具。
GitHub地址：https://github.com/meili/minui

5.Wux WeApp：Wux WeApp也是一个非常不错的微信小程序自定义 UI 组件库，组件比较丰富，值得使用。
GitHub地址：https://github.com/wux-weapp/wux-weapp npm下载：npm i wux-weapp

6.ColorUI：ColorUI是一个Css类的UI组件库！不是一个Js框架。相比于同类小程序组件库，ColorUI更注重于视觉交互！其组件在美观性方面比较突出。
GitHub地址：https://github.com/weilanwl/ColorUI
```

### 5.6.2 iView基本使用

<https://weapp.iviewui.com/docs/guide/start>

```javascript
1.将 dist 目录拷贝到自己的项目中。然后按照如下的方式使用组件，以 Button 为例，其它组件在对应的文档页查看：

2. 添加需要的组件。在页面的 json 中配置（路径根据自己项目位置配置）：

"usingComponents": {
    "i-button": "../../dist/button/index"
}

3. 在 wxml 中使用组件：

<i-button type="primary" bind:click="handleClick">这是一个按钮</i-button>
```

### 5.6.3 字体图标的使用

1、第一步：我们需要进入Font Awesome官网下载字体图标的文件

![1576234396718](assets\1576234396718.png)

2、第二步：我们需要用到一个Transfonter生成工具。打开刚才下载的文件，在fonts文件夹找到fontawesome-webfont.ttf

打开Transfonter官网，将fontawesome-webfont.ttf上传，选择base64编码，然后convert

![1576234431715](assets\1576234431715.png)

3、第三步：等待转换，转换完成后，点击download下载，下载完成后打开文件，找到stylesheet.css，将源码复制下来，然后进入小程序，将复制的代码放到app.wxss

![1576234446512](assets\1576234446512.png)

4、最后一步：找到font-awesome里的font-awesome.css，除去第一段，将其他的都复制下来放到app.wxss，然后按照font-awesome的规范来用就可以了

![1576234462972](assets\1576234462972.png)

5、使用字体图标

```
@import '../../styles/stylesheet.wxss'

<i class="fa fa-play"></i>
```

# 6.小程序的页面跳转

## 6.1 页面跳转传值

	在微信小程序开发工具中，我们可以编辑app.json中的pages字段来快速创建页面，比如

```javascript
 "pages": [
    "pages/demo1/demo1",
    "pages/demo2/demo2",
    "pages/demo3/demo3"
  ],
```

	此时会自动帮我们创建demo1、demo2、demo3三个页面

### 6.1.1 使用url传参

```javascript
//1.demo1.wxml
<view>
    <!--hover-class="none" 去除点击导航按钮的样式-->
   <navigator url="/pages/demo2/demo2?name=zhangsan&age=12" hover-class="none">跳转demo2</navigator>
</view>

//2.demo2.js
//在onload方法中通过options来获取页面1传递的参数
  onLoad: function (options) {
    console.log(options)
  },
```

### 6.1.2 编程式导航传参

```javascript
wx.navigateTo({
  url: 'test?id=1',
  events: {
    // 为指定事件添加一个监听器，获取被打开页面传送到当前页面的数据
    acceptDataFromOpenedPage: function(data) {
      console.log(data)
    },
    someEvent: function(data) {
      console.log(data)
    }
    ...
  },
  success: function(res) {
    // 通过eventChannel向被打开页面传送数据
    res.eventChannel.emit('acceptDataFromOpenerPage', { data: 'test' })
  }
})


//test.js
Page({
  onLoad: function(option){
    console.log(option.query)
    const eventChannel = this.getOpenerEventChannel()
    eventChannel.emit('acceptDataFromOpenedPage', {data: 'test'});
    eventChannel.emit('someEvent', {data: 'test'});
    // 监听acceptDataFromOpenerPage事件，获取上一页面通过eventChannel传送到当前页面的数据
    eventChannel.on('acceptDataFromOpenerPage', function(data) {
      console.log(data)
    })
  }
})
```

## 6.2 导航模式

<https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html>

```javascript
<view>
   <navigator url="/pages/demo2/demo2?name=zhangsan&age=12" open-type="redirectTo" >跳转demo2</navigator>
</view>

navigate   打开新页面，新页面会压栈
redirect    页面重定向，新页面不会压栈，而是把原来的页面替换掉
navigateBack   回到上一个页面
reLaunch    重新加载指定页面，页面全部出栈，只留下新的页面
switchTab   tab切换，页面全部出栈，只留下新的 Tab 页面



//注意点：
navigate, redirect 只能打开非 tabBar 页面。
switchTab 只能打开 tabBar 页面。
reLaunch 可以打开任意页面。
```

```javascript
//回退两层，可以通过getCurrentPages()方法来查看栈中的页面个数
wx.navigateBack({
    //当delta超出历史记录，返回首页
    delta:2
})
```

## 6.3 页面数据共享

### 6.3.1 使用全局变量

```javascript
//app.js
  App({
  onLaunch: function () {
    // 登录
    wx.login({
      success: res => {
        // 发送 res.code 到后台换取 openId, sessionKey, unionId
      }
    })
  },
  // 全局变量
  globalData: {
    userInfo: null
  }
})



onLoad: function (options) {
    var app = getApp();
    if (app.globalData.userInfo === null){
      this.setData({ "haveLogin": false});
    }else {
      this.setData({ "haveLogin": true});
    }
  },
```

### 6.3.2 使用缓存

```javascript
//缓存数据
//不管什么数据，最终都会调用toString()将数据转换成字符串存进去
wx.setStorage({
    key: 'userInfo',
    data: res.userInfo
})


getUsersInfo: function () {
    //读取缓存登录
    wx.getStorage({
        key: 'userInfo',
        success: function (res) {
            this.userInfo = res.userInfo;
        }
    })
}
```

# 7 生命周期

## 7.1 应用的生命周期

```javascript
App({})     App方法的作用：用来创建应用程序对象，并指定应用程序的生命周期

//app.js
App({
  //  1 应用第一次启动的就会触发的事件  
  onLaunch() {
    //  在应用第一次启动的时候 获取用户的个人信息 
    // console.log("onLaunch");
    // aabbcc

    // js的方式来跳转 不能触发 onPageNotFound
    // wx.navigateTo({
    //   url: '/11/22/33'
    // });
      
  },

  // 2 应用 被用户看到 
  onShow(){
    // 对应用的数据或者页面效果 重置 
    // console.log("onShow");
  },
  // 3 应用 被隐藏了 
  onHide(){
    // 暂停或者清除定时器 
    // console.log("Hide");
  },
  // 4 应用的代码发生了报错的时候 就会触发
  onError(err){
    // 在应用发生代码报错的时候，收集用户的错误信息，通过异步请求 将错误的信息发送后台去
    // console.log("onError");
    // console.log(err);
  },
  // 5 页面找不到就会触发 
  //  应用第一次启动的时候，如果找不到第一个入口页面 才会触发
  onPageNotFound(){
    // 如果页面不存在了 通过js的方式来重新跳转页面 重新跳到第二个首页
    // 不能跳到tabbar页面  导航组件类似  
    wx.navigateTo({
      url: '/pages/demo09/demo09' 
    });  
      
    // console.log("onPageNotFound");
  },
   //全局数据
  globalData: 'I am global data'
})
```

![1576227793464](assets\1576227793464.png)

![1576228221331](assets\1576228221331.png)

![1570002017840](assets/1570002017840.png)

## 7.2 页面的生命周期

<https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/route.html>

```javascript
index.js  负责页面的逻辑
index.wxml  页面的内容，严格遵循xml规范
index.wxss  页面的样式
index.json   页面的配置文件
```

```javascript
// pages/demo18/demo18.js
Page({

  /**
   * 页面的初始数据
   */
  data: {

  },

  /**
   * 生命周期函数--监听页面加载
   */
  onLoad: function (options) {
    console.log("onLoad");
    // onLoad发送异步请求来初始化页面数据 
  },
  /**
   * 生命周期函数--监听页面显示
   */
  onShow: function () {
    console.log("onShow");
  },
  /**
    * 生命周期函数--监听页面初次渲染完成
    */
  onReady: function () {
    console.log("onReady");
  },
  /**
   * 生命周期函数--监听页面隐藏
   */
  onHide: function () {
    console.log("onHide");
  },

  /**
   * 生命周期函数--监听页面卸载 也是可以通过点击超链接来演示 
   * 
   */
  onUnload: function () {
    console.log("onUnload");
  },

  /**
   * 页面相关事件处理函数--监听用户下拉动作
   */
  onPullDownRefresh: function () {
    console.log("onPullDownRefresh");
    // 页面的数据 或者效果 重新 刷新
  },

  /**
   * 页面上拉触底事件的处理函数
   * 需要让页面 出现上下滚动才行 
   */
  onReachBottom: function () {
    console.log("onReachBottom");
    // 上拉加载下一页数据 
  },

  /**
   * 用户点击右上角分享
   */
  onShareAppMessage: function () {
    console.log("onShareAppMessage");
  },
  /**
   * 页面滚动 就可以触发 
   */
  onPageScroll(){
    console.log("onPageScroll");
  },
  /**
   * 页面的尺寸发生改变的时候 触发
   * 小程序 发生了 横屏竖屏 切换的时候触发 
   */
  onResize(){
    console.log("onResize");
  },
  /**
   * 1 必须要求当前页面 也是tabbar页面
   * 2 点击的自己的tab item的时候才触发
   */
  onTabItemTap(){
    console.log("onTabItemTap");
  }
})



<!--pages/demo18/demo18.wxml-->
<text>pages/demo18/demo18.wxml</text>

<navigator url="/pages/demo17/demo17" open-type="navigate">
  demo17
</navigator>
  
<navigator url="/pages/demo17/demo17" open-type="redirect">
  demo17 redirect
</navigator>
<view>1</view>
<view>2</view>
<view>3</view>
<view>4</view>
<view>5</view>
<view>6</view>
<view>7</view>
<view>8</view>
<view>9</view>
<view>10</view>
<view>11</view>
<view>12</view>
<view>13</view>
<view>14</view>
<view>15</view>
<view>16</view>
<view>17</view>
<view>18</view>
<view>19</view>
<view>20</view>
<view>21</view>
<view>22</view>
<view>23</view>
<view>24</view>
<view>25</view>
<view>26</view>
<view>27</view>
<view>28</view>
<view>29</view>
<view>30</view>
<view>31</view>
<view>32</view>
<view>33</view>
<view>34</view>
<view>35</view>
<view>36</view>
<view>37</view>
<view>38</view>
<view>39</view>
<view>40</view>
<view>41</view>
<view>42</view>
<view>43</view>
<view>44</view>
<view>45</view>
<view>46</view>
<view>47</view>
<view>48</view>
<view>49</view>
<view>50</view>

/*demo18.json:如果要onResize执行，需要开启屏幕旋转*/
{
    "pageOrientation": "auto"
}
```

![1576227820608](assets\1576227820608.png)

# 8.微信小程序开放能力

```javascript
 <!-- 
  button 开放能力
  open-type：
  1 contact 直接打开客服对话功能  需要在微信小程序的后台配置   只能够通过真机调试来打开 
  2 share 转发当前的小程序 到微信朋友中   不能把小程序 分享到 朋友圈 
  3 getPhoneNumber 获取当前用户的手机号码信息 结合一个事件来使用  不是企业的小程序账号没有权限来获取用户的手机号码 
    a) 绑定一个事件 bindgetphonenumber 
    b) 在事件的回调函数中  通过参数来获取信息 
    c) 获取到的信息  已经加密过了 
      需要用户自己待见小程序的后台服务器，在后台服务器中进行解析手机号码，返回到小程序中 就可以看到信息了
  4 getUserInfo 获取当前用户的个人信息
    a) 使用方法 类似 获取用户的手机号码
    b) 可以直接获取 不存在加密的字段 
  5 launchApp 在小程序当中 直接打开 app
    a) 需要现在 app中 通过app的某个链接 打开 小程序
    b) 在小程序 中 再通过 这个功能 打开 app
  6 openSetting 打开小程序内置的 授权页面
    a) 授权页面中 只会出现 用户曾经点击过的 权限 
  7 feedback 打开 小程序内置的 意见反馈页面 
    a) 只能够通过真机调试来打开 
  -->
<button open-type="contact">contact</button>
<button open-type="share">share</button>
<button open-type="getPhoneNumber" bindgetphonenumber="getPhoneNumber">getPhoneNumber</button>
<button open-type="getUserInfo" bindgetuserinfo="getUserInfo">getUserInfo</button>
<button open-type="launchApp">launchApp</button>
<button open-type="openSetting">openSetting</button>
<button open-type="feedback">feedback</button>
```

## 8.1 获取用户信息

```javascript
<button 
	wx:if="{{canIUse}}" 
	open-type="getUserInfo" 
	bindgetuserinfo="bindGetUserInfo"
>获取用户信息</button>
<view wx:else>请升级微信版本</view>


//获取应用实例
const app = getApp()
Page({
  data: {
    //判断小程序的API，回调，参数，组件等是否在当前版本可用。
    canIUse: wx.canIUse('button.open-type.getUserInfo')
  },
  bindGetUserInfo: function (e) {
    console.log(e.detail.userInfo)
    if (e.detail.userInfo) {
      //用户按了允许授权按钮
    } else {
      //用户按了拒绝按钮
    }
  }
})
```

## 8.2 登陆

<https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html>

```javascript
  <button bindtap="loginHandler">login</button>
  
  
   loginHandler:function(e){
    wx.login({
      success:(res)=>{
        console.log(res)
      }
    })
  }
  
  
 //关于openid获取   openid是小程序的唯一标识，做支付功能的时候需要用到openid(支付需要企业账号)
https://www.cnblogs.com/legendheng/p/9469173.html
```

## 8.3 打开客服

a. 把微信小程序测试号换成我们注册的账号

b.到微信小程序后台配置客服人员

![1576224742351](assets\1576224742351.png)

c.添加开发者

![1576225645067](assets\1576225645067.png)

d.用户用微信扫一扫打开小程序，然后点击contact就可以和客服人员聊天了

e.管理员可以登录网页端客服或 移动端小程序客服 进行客服沟通

## 8.4 转发

```javascript
<button class='share' id="shareBtn" open-type="share" type="primary">
  分享
</button>


//获取应用实例
const app = getApp()
Page({
  onLoad: function (options) {
    console.log(options);
  },
  /**
  * 进行页面分享
  */
  onShareAppMessage: function (options) {
    if (options.from === 'button') {
      // 来自页面内转发按钮
      console.log(options.target)
    }
    return {
      //## 此为转发页面所显示的标题
      title: '好友代付', 
      //## 此为转发给微信好友或微信群后，对方点击后进入的页面链接在onload中的options中可以获取到参数
      path: 'pages/profile/profile?sn=123', 
      //## 转发操作成功后的回调函数，用于对发起者的提示语句或其他逻辑处理
      //https://mp.weixin.qq.com/s?__biz=MjM5NDAwMTA2MA==&mid=2695730124&idx=1&sn=666a448b047d657350de7684798f48d3&chksm=83d74a07b4a0c311569a748f4d11a5ebcce3ba8f6bd5a4b3183a4fea0b3442634a1c71d3cdd0&scene=21#wechat_redirect
      success: function (res) {
        // 转发成功
        console.log("转发成功:" + JSON.stringify(res));
      },
      fail: function (res) {
        // 转发失败
        console.log("转发失败:" + JSON.stringify(res));
      }
    }
  },
})
```

## 8.5 获取用户地址

### 8.5.1 基于回调的解决方案

```javascript
handleChooseAddress(){
    //获取之前的设置状态
    wx.getSetting({
        success:(result)=>{
            //获取用户之前对于地址的操作
            const scopeAddress = result.authSetting['scope.address'];
            //如果从来没有点击过或者同意用户地址的授权
            if(scopeAddress===true||scopeAddress===undefined){
                //选择收获地址
                wx.chooseAddress({
                    success:(result1)=>{
                        console.log(result1);
                    }
                });
            }
            //如果用户之前点击了拒绝
            else{
                //打开设置页面
                wx.openSetting({
                    success:(result2)=>{
                        //重新选择收获地址
                        wx.chooseAddress({
                            success:(result3)=>{
                                console.log(result3);
                            }
                        })
                    }
                })
            }
        }
    })
}
```

### 8.5.2 基于async 的解决放案

1. 在小程序的开发共具中，勾选 es6转es5语法

2. 下载 facebook的regenerator库中的 regenerator/packages/regenerator-runtime/runtime.js

   <https://github.com/facebook/regenerator/blob/5703a79746fffc152600fdcef46ba9230671025a/packages/regenerator-runtime/runtime.js>

3. 在小程序目录下新建文件夹 lib/runtime/runtime.js ，将代码拷贝进去

4. 在每一个需要使用async语法的js文件中，都引用（不能全局引用）

```javascript
import { getSetting, chooseAddress, openSetting} from "../../utils/asyncWx.js";
import regeneratorRuntime from '../../lib/runtime/runtime';
  
  async handleChooseAddress() {
    try {
      // 1 获取 权限状态
      const res1 = await getSetting();
      const scopeAddress = res1.authSetting["scope.address"];
      // 2 判断 权限状态
      if (scopeAddress === false) {
        await openSetting();
      }
      // 4 调用获取收货地址的 api
      let address = await chooseAddress();
      console.log(address)

    } catch (error) {
      console.log(error);
    }
  },
  
  
  
  //asyncWx.js
  /**
 * promise 形式  getSetting
 */
export const getSetting=()=>{
  return new Promise((resolve,reject)=>{
    wx.getSetting({
      success: (result) => {
        resolve(result);
      },
      fail: (err) => {
        reject(err);
      }
    });
  })
}
/**
 * promise 形式  chooseAddress
 */
export const chooseAddress=()=>{
  return new Promise((resolve,reject)=>{
    wx.chooseAddress({
      success: (result) => {
        resolve(result);
      },
      fail: (err) => {
        reject(err);
      }
    });
  })
}

/**
 * promise 形式  openSetting
 */
export const openSetting=()=>{
  return new Promise((resolve,reject)=>{
    wx.openSetting({
      success: (result) => {
        resolve(result);
      },
      fail: (err) => {
        reject(err);
      }
    });
  })
}
```

# 9.本地生活项目

## 9.1 小程序外观、工具栏和公共样式

```javascript
#app.json
{
  "pages": [
    "pages/index/index",
    "pages/message/message",
    "pages/profile/profile"
  ],
  "window": {
    "backgroundTextStyle": "light",
    "navigationBarBackgroundColor": "#3a4861",
    "navigationBarTitleText": "本地生活",
    "navigationBarTextStyle": "black",
    "backgroundColor":"#bcc0c9"
  },
  "sitemapLocation": "sitemap.json",
  "tabBar": {
    "color": "#999",
    "selectedColor": "#333",
    "borderStyle": "black",
    "position": "bottom",
    "backgroundColor":"#fff",
    "list": [
      {
        "pagePath": "pages/index/index",
        "text": "首页",
        "iconPath": "assets/tabs/home.png",
        "selectedIconPath": "assets/tabs/home-active.png"
      },
      {
        "pagePath": "pages/message/message",
        "text": "消息",
        "iconPath": "assets/tabs/message.png",
        "selectedIconPath": "assets/tabs/message-active.png"
      },
      {
        "pagePath": "pages/profile/profile",
        "text": "我的",
        "iconPath": "assets/tabs/profile.png",
        "selectedIconPath": "assets/tabs/profile-active.png"
      }
    ]
  }
}


#2.app.wxss
page {
  background-color: #f0f0f0;
  font-size:18rpx;
}
```

## 9.2 首页布局

```javascript
<!-- 首页轮播图分区 -->
<view class='sliders'>
    <swiper indicator-dots="{{true}}" autoplay="{{true}}" interval="2500" duration="400" circular>
        <swiper-item>
          <image src="/assets/images/banner-01.png" mode="aspectFill"></image>
        </swiper-item>
        <swiper-item>
          <image src="/assets/images/banner-02.png" mode="aspectFill"></image>
        </swiper-item>
    </swiper>
</view>
<!-- 首页导航分区 -->
<view class='grids bgw'>
    <navigator class="item">
        <image src='/assets/icons/grid-01.png' lazy-load></image>
        <text>测试</text>
    </navigator>
     <navigator  class="item">
        <image src='/assets/icons/grid-02.png' lazy-load></image>
        <text>测试</text>
    </navigator>
     <navigator  class="item">
        <image src='/assets/icons/grid-03.png' lazy-load></image>
        <text>测试</text>
    </navigator>
     <navigator  class="item">
        <image src='/assets/icons/grid-04.png' lazy-load></image>
        <text>测试</text>
    </navigator>
     <navigator  class="item">
        <image src='/assets/icons/grid-05.png' lazy-load></image>
        <text>测试</text>
    </navigator>
     <navigator  class="item">
        <image src='/assets/icons/grid-06.png' lazy-load></image>
        <text>测试</text>
    </navigator>
     <navigator  class="item">
        <image src='/assets/icons/grid-07.png' lazy-load></image>
        <text>测试</text>
    </navigator>
     <navigator  class="item">
        <image src='/assets/icons/grid-08.png' lazy-load></image>
        <text>测试</text>
    </navigator>
     <navigator  class="item">
        <image src='/assets/icons/grid-09.png' lazy-load></image>
        <text>测试</text>
    </navigator>
</view>
<!-- 首页入口分区 -->
<view class='enter'>
    <navigator class='item'>
        <image src='/assets/images/link-01.png'></image>
    </navigator>
    <navigator class='item'>
        <image src='/assets/images/link-02.png'></image>
    </navigator>
</view>



/*1.轮播图样式*/
.sliders{
  height: 300rpx;
}

.sliders image{
  /*1.图片需要设置宽高，如果不设置宽高，微信小程序中的图片会有默认的宽高
     2.这边当图片设置宽高之后，发现图片失真了，此时需要设置image的mode
     https://developers.weixin.qq.com/miniprogram/dev/component/image.html

https://blog.csdn.net/qq_2842405070/article/details/69382503
     */
  width: 100%;
  height: 100%;
}


/*首页九宫格样式*/
.grids{
  display: flex;
  flex-wrap: wrap;
  font-size: 28rpx;
  color: #888;
}

.grids .item{
  width: 250rpx;
  height: 250rpx;
  border-right: 1rpx solid #ddd;
  border-top: 1rpx solid #ddd;
  box-sizing: border-box;
  /*让item内容在item容器内水平垂直居中*/
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
}

/*给3的倍数的item添加做边框*/
.grids .item:nth-last-child(3n){
   border-left: 1rpx solid #ddd;
}
/*给第7 8 9 个item添加下边框*/
.grids .item:nth-child(n+7){
  border-bottom: 1rpx solid #ddd;
}

.grids .item image{
  width: 70rpx;
  height: 70rpx;
}

.grids .item text{
  margin-top: 20rpx;
}


/*首页入口样式*/
.enter {
    display: flex;
    padding: 20rpx 25rpx;
}

.enter .item {
    width: 50%;
    display: flex;
    justify-content: center;
}

.enter image {
    width: 320rpx;
    height: 178rpx;
}
```

## 9.3 首页请求数据

### 9.3.1 wx.request基本使用

<https://developers.weixin.qq.com/miniprogram/dev/api/network/request/wx.request.html>

<https://developers.weixin.qq.com/miniprogram/dev/framework/ability/network.html>

```javascript
Page({
  data:{

  },
  onLoad:function(options){
    //小程序中没有跨域问题
    wx.request({
      //请求地址
      url: 'https://locally.uieee.com/slides',
      //请求方式
      method:"get",
      //请求参数
      data:{},
      //设置请求头
      header: {},
      //请求返回结果的数据类型
      dataType:"json",
      //请求回调
      success:function(res){
        console.log(res);
      },
      // 请求失败执行的回调函数
      fail: function(res) {},
       // 接口调用结束的回调函数（调用成功、失败都会执行）
       complete: function(res) {},
    })
  }
})
```

![1569742369137](assets\1569742369137.png)

发现报错，原因是微信小程序中发请求得先在小程序后台配置合法的域名请求列表。

![1569742448980](assets\1569742448980.png)

![1569742508228](assets\1569742508228.png)

	此时发现可以正常请求网络了。

> 注意点：

	小程序在线上的版本都是需要使用https的请求,同时只能请求到自己在微信公众号中配置好的https服务器。不过在开发环境中,在电脑上的微信web开具中的 详情底下的不进行https校验打上勾即可发送http请求,也使用小程序request的api进行发送.

![1569742566195](assets\1569742566195.png)



	关于搭建https服务器，参照服务器搭建部分内容。

### 9.3.2 首页完成数据请求和绑定

```javascript
Page({
  data:{
    sliderList:[],
    navList:[]
  },
  onLoad:function(options){
    wx.request({
      url: "https://locally.uieee.com/slides",
      success: (res) => {
        console.log(res);
        /**
         *   this.setData 有两个功能：
         *      1. 更新数据
         *      2. 更新视图
         * */
        this.setData({
          sliderList: res.data
        });
      },
    });
    /* 2.请求导航 */
    wx.request({
      url: "https://locally.uieee.com/categories",
      //这边使用箭头函数来解决函数中的this问题
      success: (res) => {
        // console.log(res);
        /**
         *   this.setData 有两个功能：
         *      1. 更新数据
         *      2. 更新视图
         * */
        this.setData({
          navList: res.data
        });
      },
    });
  }
})



<!-- 首页轮播图分区 -->
<view class='sliders'>
    <swiper indicator-dots="true" autoplay="true" interval="2500" duration="400" circular>
        <swiper-item wx:for="{{sliderList}}" wx:key="id">
          <image src="{{item.image}}" mode="aspectFill"></image>
        </swiper-item>
    </swiper>
</view>
<!-- 首页导航分区 -->
<view class='grids bgw'>
    <navigator class="item" wx:for="{{navList}}" wx:key="id">
        <image src='{{item.icon}}' lazy-load></image>
        <text>{{item.name}}</text>
    </navigator>
</view>
```

### 9.3.3 请求工具类的封装

```javascript
//utils/fetch.js

// 同时发送异步代码的次数
let ajaxTimes=0;
module.exports = (url, data) => {
  ajaxTimes++;
  // 显示加载中 效果
  wx.showLoading({
    title: "加载中",
    mask: true
  });
    
  return new Promise((resolve, reject) => {
    wx.request({
      url: `https://locally.uieee.com/${url}`,
      data:data,
      success: resolve,
      fail: reject,
      complete:()=>{
         ajaxTimes--;
         if(ajaxTimes===0){
             //  关闭正在等待的图标
             wx.hideLoading();
         }
       }
    })
  })
};


//index/index.js
const fetch = require('../../utils/fetch.js')

onLoad:function(options){
    fetch("slides").then(res=>{
      this.setData({
        sliderList: res.data
      });
    })

    fetch("categories").then(res => {
      this.setData({
        navList: res.data
      });
    })
  }
```

## 9.4 列表页面

### 9.4.1 首页跳转到列表页面

```javascript
 //1.app.json
 "pages": [
    "pages/index/index",
    "pages/message/message",
    "pages/profile/profile",
    "pages/list/list"
  ],


//2.index.wxml
<!-- 首页导航分区 -->
<view class='grids bgw'>
    <navigator class="item" url="/pages/list/list?category={{item.id}}" wx:for="{{navList}}" wx:key="id">
        <image src='{{item.icon}}' lazy-load></image>
        <text>{{item.name}}</text>
    </navigator>
</view>


//3.list.js
 onLoad: function (options) {
    console.log(options.category)
  },
```

### 9.4.2 扩展组件的使用

<https://developers.weixin.qq.com/miniprogram/dev/extended/weui/quickstart.html>

```javascript
//1.下载相关需要使用的组件
//2.在需要引入扩展组件的页面模块中，修改.json文件
//3.使用扩展组件


//1.list.json
{
  "usingComponents": {
    "mp-searchbar": "../components/searchbar/searchbar"
  }
}

//2.list.wxml
<mp-searchbar placeholder="请输入关键字搜索" bindselectresult="selectResult" search="{{search}}"></mp-searchbar>

//3.list.js
Page({
  data: {
    hasMore:true,
    
  },
  onLoad: function (options) {
    console.log(options.category)
    this.setData({
      search: this.search.bind(this)
    })
  },
  search: function (value) {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        //在这更改数据源
        resolve([{ text: '搜索结果', value: 1 }, { text: '搜索结果2', value: 2 }])
      }, 200)
    })
  },
  //选中某个搜索结果后
  selectResult: function (e) {
    console.log('select result', e.detail)
  }
})
```

### 9.4.3 列表页面布局

```javascript
<mp-searchbar placeholder="请输入关键字搜索" bindselectresult="selectResult" search="{{search}}"></mp-searchbar>

<view class="shop">
    <image class="shop-img" src="http://p0.meituan.net/200.0/deal/5511b4e5b25fdd67aea0bbca8656ec581139488.jpg@200_0_800_800a%7C267h_267w_2e_90Q"></image>
    <view class="shop-info">
        <text class="shop-title ell">模板：店铺名称很长很长很长很长很长很长</text>
        <text class="shop-tel">电话：</text>
        <text class="shop-address">地址：</text>
        <text class="shop-time">营业时间：</text>
    </view>
    <view class="shop-star">
        <view class='star-after'>★★★★★</view>
        <view class='star-before' style="width:50%;">★★★★★</view>
    </view>
</view>

<view class="loadmore loading" wx:if="{{ hasMore }}">正在加载...</view>
<view class="loadmore" wx:else>你已经到达我的底线了</view>



page{
  background-color: #fff
}
.shop{
  padding: 20rpx;
  border-bottom: 1rpx solid #ddd;
  display: flex;
  position: relative

}
.shop-img{
  width: 160rpx;
  height:  160rpx;
  margin-right: 20rpx
}
.shop-info{
 width: 370rpx;
 display: flex;
 flex-direction: column;
 font-size: 12px;
 color: #666;
 line-height: 1.5;
}
.shop-title{
  font-size: 16px;
  color: #333;
  
}
.shop-star{
  position: absolute;
  right: 20rpx;
  top: 20rpx;
}
/*评分星星*/
.star-after{
  color: #e2e2e2;
}

.star-before{
  color: #f19138;
  position: absolute;
  left: 0px;
  top:0px;
  overflow: hidden;
}

.loadmore{
  text-align: center;
  color: #888;
}
```

### 9.4.4 列表页面导航栏标题

```javascript
  onLoad: function (options) {
    console.log(options.category)
    this.setData({
      search: this.search.bind(this)
    })

    //这边有可能请求回来之后，onready还没有执行，因此设置导航栏标签的事情应该在onread函数中执行，此时能确保页面加载完毕
    fetch(`categories/${options.category}`).then(res => {
      wx.setNavigationBarTitle({
        title: res.data.name
      })
    })
  },
```

### 9.4.5 列表页面数据获取显示

```javascript
const fetch = require('../../utils/fetch.js')

// pages/list/list.js
Page({
  data: {
    hasMore: true,
    title: "",
    shopList: [],
    pageSize: 20,
    pageIndex: 0,
    category:null
  },

  /**
   * 生命周期函数--监听页面加载
   */
  onLoad: function(options) {
    console.log(options.category)
    this.setData({
      search: this.search.bind(this),
      category: options.category
    })

    //这边有可能请求回来之后，onready还没有执行，因此设置导航栏标签的事情应该在onread函数中执行，此时能确保页面加载完毕
    fetch(`categories/${options.category}`).then(res => {
      wx.setNavigationBarTitle({
        title: res.data.name
      })
    })

    //根据分页请求列表数据
    var data = {
      _limit: this.data.pageSize,
      _page: ++this.data.pageIndex
    }
    fetch(`categories/${options.category}/shops`, data).then(res => {
      console.log(res)
      var newList = this.data.shopList.concat(res.data);
      // 2.3 获取数据的总数
      var count = parseInt(res.header['X-Total-Count']);
      // 2.4 用于判断比较是否还有更多数据
      var flag = this.data.pageIndex * this.data.pageSize < count;
      this.setData({
        shopList: newList,
        hasMore: flag,
      });
    })
  },
  search: function(value) {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        //在这更改数据源
        resolve([{
          text: '搜索结果',
          value: 1
        }, {
          text: '搜索结果2',
          value: 2
        }])
      }, 200)
    })
  },
  //选中某个搜索结果后
  selectResult: function(e) {
    console.log('select result', e.detail)
  },
})



<view class="shop" wx:for="{{ shopList }}" wx:key="id">
    <image class="shop-img" src="{{ item.images[0] }}"></image>
    <view class="shop-info">
        <text class="shop-title ell">{{ item.name }}</text>
        <text class="shop-tel">电话：{{ item.phone }}</text>
        <text class="shop-address">地址：{{ item.address }}</text>
        <text class="shop-time">营业时间：{{ item.businessHours }}</text>
    </view>
    <view class="shop-star">
        <view class='star-after'>★★★★★</view>
        <view class='star-before' style="width:{{ item.score }}%;">★★★★★</view>
    </view>
</view>
```

### 9.4.6 上拉加载实现

```javascript
//加载更多样式

//app.wxss
.loadmore {
    color: #888;
    font-size: 16px;
    line-height: 100rpx;
    text-align: center;
}

.loadmore.loading::before {
    content: '';
    width: 40rpx;
    height: 40rpx;
    margin-top: -10rpx;
    margin-right: 10rpx;
    display: inline-block;
    vertical-align: middle;
    animation: loading 1s steps(12) infinite;
    background: transparent url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMjAiIGhlaWdodD0iMTIwIiB2aWV3Qm94PSIwIDAgMTAwIDEwMCI+PHBhdGggZmlsbD0ibm9uZSIgZD0iTTAgMGgxMDB2MTAwSDB6Ii8+PHJlY3Qgd2lkdGg9IjciIGhlaWdodD0iMjAiIHg9IjQ2LjUiIHk9IjQwIiBmaWxsPSIjRTlFOUU5IiByeD0iNSIgcnk9IjUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAgLTMwKSIvPjxyZWN0IHdpZHRoPSI3IiBoZWlnaHQ9IjIwIiB4PSI0Ni41IiB5PSI0MCIgZmlsbD0iIzk4OTY5NyIgcng9IjUiIHJ5PSI1IiB0cmFuc2Zvcm09InJvdGF0ZSgzMCAxMDUuOTggNjUpIi8+PHJlY3Qgd2lkdGg9IjciIGhlaWdodD0iMjAiIHg9IjQ2LjUiIHk9IjQwIiBmaWxsPSIjOUI5OTlBIiByeD0iNSIgcnk9IjUiIHRyYW5zZm9ybT0icm90YXRlKDYwIDc1Ljk4IDY1KSIvPjxyZWN0IHdpZHRoPSI3IiBoZWlnaHQ9IjIwIiB4PSI0Ni41IiB5PSI0MCIgZmlsbD0iI0EzQTFBMiIgcng9IjUiIHJ5PSI1IiB0cmFuc2Zvcm09InJvdGF0ZSg5MCA2NSA2NSkiLz48cmVjdCB3aWR0aD0iNyIgaGVpZ2h0PSIyMCIgeD0iNDYuNSIgeT0iNDAiIGZpbGw9IiNBQkE5QUEiIHJ4PSI1IiByeT0iNSIgdHJhbnNmb3JtPSJyb3RhdGUoMTIwIDU4LjY2IDY1KSIvPjxyZWN0IHdpZHRoPSI3IiBoZWlnaHQ9IjIwIiB4PSI0Ni41IiB5PSI0MCIgZmlsbD0iI0IyQjJCMiIgcng9IjUiIHJ5PSI1IiB0cmFuc2Zvcm09InJvdGF0ZSgxNTAgNTQuMDIgNjUpIi8+PHJlY3Qgd2lkdGg9IjciIGhlaWdodD0iMjAiIHg9IjQ2LjUiIHk9IjQwIiBmaWxsPSIjQkFCOEI5IiByeD0iNSIgcnk9IjUiIHRyYW5zZm9ybT0icm90YXRlKDE4MCA1MCA2NSkiLz48cmVjdCB3aWR0aD0iNyIgaGVpZ2h0PSIyMCIgeD0iNDYuNSIgeT0iNDAiIGZpbGw9IiNDMkMwQzEiIHJ4PSI1IiByeT0iNSIgdHJhbnNmb3JtPSJyb3RhdGUoLTE1MCA0NS45OCA2NSkiLz48cmVjdCB3aWR0aD0iNyIgaGVpZ2h0PSIyMCIgeD0iNDYuNSIgeT0iNDAiIGZpbGw9IiNDQkNCQ0IiIHJ4PSI1IiByeT0iNSIgdHJhbnNmb3JtPSJyb3RhdGUoLTEyMCA0MS4zNCA2NSkiLz48cmVjdCB3aWR0aD0iNyIgaGVpZ2h0PSIyMCIgeD0iNDYuNSIgeT0iNDAiIGZpbGw9IiNEMkQyRDIiIHJ4PSI1IiByeT0iNSIgdHJhbnNmb3JtPSJyb3RhdGUoLTkwIDM1IDY1KSIvPjxyZWN0IHdpZHRoPSI3IiBoZWlnaHQ9IjIwIiB4PSI0Ni41IiB5PSI0MCIgZmlsbD0iI0RBREFEQSIgcng9IjUiIHJ5PSI1IiB0cmFuc2Zvcm09InJvdGF0ZSgtNjAgMjQuMDIgNjUpIi8+PHJlY3Qgd2lkdGg9IjciIGhlaWdodD0iMjAiIHg9IjQ2LjUiIHk9IjQwIiBmaWxsPSIjRTJFMkUyIiByeD0iNSIgcnk9IjUiIHRyYW5zZm9ybT0icm90YXRlKC0zMCAtNS45OCA2NSkiLz48L3N2Zz4=) no-repeat;
    background-size: 100%;
}

@keyframes loading {
    0% {
        transform: rotate(0deg);
    }

    100% {
        transform: rotate(-360deg);
    }
}
```

```javascript
//1.list.json
{
  "usingComponents": {
    "mp-searchbar": "../components/searchbar/searchbar"
  },
  "onReachBottomDistance":20
}

//2.list.js
onReachBottom:function(){
    console.log("xxx")
}
```

```javascript
const fetch = require('../../utils/fetch.js')

// pages/list/list.js
Page({
  data: {
    hasMore: true,
    title: "",
    shopList: [],
    pageSize: 20,
    pageIndex: 0,
    category:null
  },

  /**
   * 生命周期函数--监听页面加载
   */
  onLoad: function(options) {
    console.log(options.category)
    this.setData({
      search: this.search.bind(this),
      category: options.category
    })

    //这边有可能请求回来之后，onready还没有执行，因此设置导航栏标签的事情应该在onread函数中执行，此时能确保页面加载完毕
    fetch(`categories/${this.data.category}`).then(res => {
      wx.setNavigationBarTitle({
        title: res.data.name
      })
    })

    this.loadMore();
  },
  loadMore:function(){
    if (!this.data.hasMore) return;
    //根据分页请求列表数据
    var data = {
      _limit: this.data.pageSize,
      _page: ++this.data.pageIndex
    }
    return fetch(`categories/${this.data.category}/shops`, data).then(res => {
      console.log(res)
      var newList = this.data.shopList.concat(res.data);
      // 2.3 获取数据的总数
      var count = parseInt(res.header['X-Total-Count']);
      // 2.4 用于判断比较是否还有更多数据
      var flag = this.data.pageIndex * this.data.pageSize < count;
      this.setData({
        shopList: newList,
        hasMore: flag,
      });
    })
  },
  onReachBottom:function(){
    console.log("xxx")
    this.loadMore();
  }
})
```

### 9.4.5 使用微信小程序API实现加载动画

https://developers.weixin.qq.com/miniprogram/dev/api/ui/interaction/wx.hideLoading.html

```javascript
wx.showNavigationBarLoading()
wx.hideNavigationBarLoading()

wx.showLoading({
    title:"努力加载中...."
})
wx.hideLoading()
```

### 9.4.6 下拉刷新

```javascript
{
  "usingComponents": {
    "mp-searchbar": "../components/searchbar/searchbar"
  },
  "onReachBottomDistance":20,
  "enablePullDownRefresh":true
}


 onPullDownRefresh: function () {
    console.log("下拉事件");
    // 下拉刷新页面
    // 3.1 把数据先设置回默认值
    this.setData({
      shopList: [],
      pageIndex: 0,
      hasMore: true,
    });
   // 3.2 再重新请求数据
    this.loadMore().then(function(){
      // 3.3 加载数据完成之后停止下拉刷新(loadMore方法返回了一个Promise)
      wx.stopPullDownRefresh();
    });
  },
```

## 9.5 详情页

### 9.5.1 wxs的使用

<https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxs/>

wxs：是小程序的一套脚本语言，结合 `WXML`，可以构建出页面的结构。主要用于编写页面内的一些模块，写一些js逻辑以便在页面使用。

```javascript
// page.js
Page({
  data: {
    a:1,
    b:2
  }
})


<!--wxml-->
<!-- 下面的 getSum 函数，接收两个值，求两个值的和 -->
<wxs module="m1">
var getSum = function(a,b) {
  var sum = undefined;
  sum = a+b
  return max;
}

module.exports.getSum = getSum;
</wxs>

<!-- 调用 wxs 里面的 getMax 函数，参数为 page.js 里面的 array -->
<view> {{m1.getSum(a,b)}} </view>

<!--注意：
1.在插值表达式中只可以这样用:{{data中的数据}}。不可以{{data中的方法}}
2.wxs中不支持es6的新特性-->
```

### 9.5.2 详情页实现

```javascript
<!-- 顶部轮播图  -->
<swiper class='slider' autoplay="{{true}}" interval="5000" duration="1000">
  <block wx:for="{{shop.images}}" wx:key="unique">
    <swiper-item>
      <!--点击图片显示预览，data-src：传递数据-->
      <image bindtap="preview" data-src="{{item}}" src="{{item}}" class="slide-image"/>
    </swiper-item>
  </block>
</swiper>


<!-- 内容区域  -->
<view class='product'>
  <text class='pro-name'>{{ shop.name }}</text>
  <text class='pro-phone'>电话: {{ shop.phone }} </text>
  <text class='pro-address'>地址: {{ shop.address }} </text>
  <text class='pro-time'>营业时间: {{ shop.businessHours }} </text>
</view>

<!-- 评论区域  -->
<view class="comments">
  <view class="item" wx:for="{{ shop.comments }}" wx:key="unique">
    <text class="name">{{ item.name }}</text>
    <text class="date">{{ item.date }}</text>
    <text class="rating">{{ item.rating }}</text>
    <text class="content">{{ item.content }}</text>
    <view class="images" >
      <image wx:for="{{ item.images }}" wx:key="unique" wx:for-item="v" src='{{ imgutil.size(v) }}'></image>
    </view>
  </view>
</view>

<!--页面内的模块：写一些js逻辑，用来替换字符串的指定内容
因为服务器给我们返回了下面的网址，下面网址直接打开是显示不了图片的，我们需要将网址中的w.h换成具体的尺寸
"http://p0.meituan.net/w.h/shaitu/4ffbaec3f82fe3b4240aedb22fee22e5267105.jpg"
-->
<!-- 注意：这里不支持es6的一些新特性  -->
<wxs module="imgutil">
  module.exports = {
    size: function( input ) {
      return input.replace("w.h", "100.100")
    }
  }
</wxs>



/* 轮播图样式  */
.slider {
  width: 750rpx;
  height: 500rpx;
}
.slider image {
  width: 100%;
  height: 100%;
}

/* 商品详情页样式  */
.product {
  display: flex;
  flex-direction: column;
  background-color: white;
  font-size: 14px;
  padding: 20rpx 30rpx;
  color: rgb(110,115,126);
  border-top: 1rpx solid #ddd;
}
.pro-name {
  font-size: 20px;
  color: rgb(56,64,74);
}


/* 评论样式  */
.comments {
  margin-top: 20rpx;
  padding: 20rpx;
  background-color: #fff;
  color: #345;
  font-size: 24rpx;
}

.comments .item {
  display: flex;
  position: relative;
  flex-direction: column;
  padding: 20rpx;
  border-bottom: 1rpx solid #eee;
}

.comments .item .name {
  margin-top: 20rpx;
  font-size: 36rpx;
}

.comments .item .date {
  align-self: flex-end;
  margin: -40rpx 0 20rpx;
  color: #567;
}

.comments .item .rating {
  position: absolute;
  top: 20rpx;
  right: 10rpx;
  color: #ee523d;
}

.comments .item image {
  width: 110rpx;
  height: 110rpx;
  margin: 10rpx;
}



const fetch = require('../../utils/fetch.js')

Page({
  data: {
    shop: {},
  },

  onLoad: function (options) {
    let shopid = options.item
    fetch(`shops/${shopid}`).then(res => {
      console.log(res.data);
      this.setData({ shop: res.data })
    })

  },

  // 该方法用于图片预览
//https://developers.weixin.qq.com/miniprogram/dev/api/media/image/wx.previewImage.html
  preview(e) {
    wx.previewImage({
      current: e.target.dataset.src, // 当前显示图片的http链接
      urls: this.data.shop.images // 需要预览的图片http链接列表
    })
  }
})
```

## 9.6 消息页

```javascript
<view class="messages">
  <view class="item" wx:for="{{ messages }}" wx:key="unquine">
    <navigator>
      <text class="title">{{ item.title }}</text>
    </navigator>
    <text class="date">{{ item.date }}</text>
    <navigator>
      <image src="{{ item.image }}"/>
    </navigator>
    <text class="summary">{{ item.summary }}</text>
    <navigator class="expand">Read All</navigator>
  </view>
</view>

<view id="bottom"></view>




.messages {
  padding: 60rpx 20rpx;
}

.messages .item {
  display: flex;
  flex-direction: column;
  margin-bottom: 60rpx;
  padding: 20rpx 35rpx;
  border: 1rpx solid #ddd;
  border-radius: 10rpx;
  background-color: #fff;
}

.messages .item:last-child {
  margin-bottom: 0;
}

.messages .item .title {
  font-size: 40rpx;
  color: #222;
}

.messages .item .date {
  margin-bottom: 10rpx;
  border-bottom: 1rpx solid #eee;
  font-size: 26rpx;
  color: #888;
}

.messages .item image {
  width: 100%;
  height: 300rpx;
  margin: 10rpx 0;
}

.messages .item .summary {
  margin-bottom: 10rpx;
  padding-bottom: 10rpx;
  border-bottom: 1rpx solid #eee;
  font-size: 28rpx;
  color: #444;
}

.messages .item .expand {
  display: flex;
  justify-content: space-between;
  align-items: center;
  color: #333;
  font-size: 30rpx;
}

.messages .item .expand::after {
  content: '';
  display: inline-block;
  margin-right: 10rpx;
  height: 10rpx;
  width: 10rpx;
  border: 0 solid #ccc;
  border-width: 3rpx 3rpx 0 0;
  transform: matrix(1, 1, -1, 1, 0, 0);
}




// pages/message/message.js
Page({

  /**
   * 页面的初始数据
   */
  data: {
    messages: []
  },

  /**
   * 生命周期函数--监听页面加载
   */
  onLoad: function (options) {
    const messages = this.data.messages
    for (var i = 0; i < 18; i++) {
      messages.push({
        title: '免费送票！超有内涵的门票。',
        date: i + ' September',
        image: 'https://unsplash.it/400/300',
        summary: '最糟糕的，也许就是最幸运的。'
      })
    }

    this.setData({ messages })
  },

  onReady() {
    const query = wx.createSelectorQuery()
    //创建一个查询请求
    query.select('#bottom').boundingClientRect()
    //执行上面的查询请求，让页面滚动到底部
    query.exec(res => wx.pageScrollTo({ scrollTop: res[0].top }))
  }
})
```

## 9.7 个人页

```javascript
<view class="avatar">
  <image src="/assets/avatar.png" bindtap="loginHandle"></image>
</view>

<view class="cells">
  <navigator class="item">个人资料</navigator>
  <navigator class="item">我的优惠券</navigator>
  <view class="divider"></view>
  <navigator class="item">常见问题</navigator>
  <navigator class="item">使用条款</navigator>
  <navigator class="item">隐私权政策</navigator>
  <navigator class="item">联系客服</navigator>
  <view class="divider"></view>
  <navigator url="/pages/setting/setting" class="item">设置</navigator>
</view>


.avatar {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 400rpx;
  background-color: #3a4861;
}

.avatar image {
  width: 220rpx;
  height: 220rpx;
  border-radius: 50%;
  box-shadow: 0 0 0 10rpx #777f92;
}

.cells {
  margin-top: 20rpx;
}

.cells .item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: relative;
  padding: 20rpx 30rpx;
  border-bottom: 1rpx solid #f0f0f0;
  background-color: #fff;
  font-size: 30rpx;
}

.cells .item::after {
  content: '';
  display: inline-block;
  height: 10rpx;
  width: 10rpx;
  border: 0 solid #ccc;
  border-width: 3rpx 3rpx 0 0;
  transform: matrix(1, 1, -1, 1, 0, 0);
}

.cells .divider {
  height: 20rpx;
  box-shadow: inset 0 1rpx 2rpx #eee;
}
```

## 9.8 小程序调试

![1570004655409](assets\1570004655409.png)

![1569997119951](assets\1569997119951.png)

## 9.9 小程序发布

1.把不校验合法域名前面的勾去掉，然后重新编译运行项目，看项目是否会出问题

![1576289706127](assets\1576289706127.png)

2.修改小程序的Appid为自己注册的ip，不要使用测试号

3.点击上传按钮，将小程序上传到微信(注意：文件不超过2M，后期可以通过分包技术上传，但是总计不超过12M)

![1576289845558](assets\1576289845558.png)

![1576290078884](assets\1576290078884.png)

4.登陆小程序后台，提交审核。审核通过之后，在线上版本会看到对应的小程序，此时就可以在微信的小程序中根据名字搜索到小程序了

![1576290196252](assets\1576290196252.png)

# 10.微信公众号开发

## 10.1 公众号分类

- 微信公众平台是腾讯旗下的一个平台，微信公众平台中有以下三种[微信公众号](https://www.baidu.com/s?wd=%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)类型：

```
1、订阅号
2、服务号
3、企业号：企业号多半是企业内容使用，用于管理员工通讯，方便员工通讯，信息集合和消息通知等功能，相当与一个移动的小型oa系统了。一般不用来对外宣传推广
```

![1570007801353](assets/1570007801353.png)

![1570007831333](assets/1570007831333.png)

- 服务号和订阅号的区别：

  ```
  1.出现的位置不同
  2.单月发送的消息数量不同，订阅号每天1篇，服务号每月4篇
  3.订阅号没有9大接口和支付功能
     9大接口包括：语音识别、客服接口、OAuth 2.0网页授权、生成带参数的二维码、获取用户地理位置、获取用户基本信息、获取关注者列表、用户分组接口、上传和下载多媒体文件
  ```

  > 微信公众号认证账号和非认证账号的区别：认证账号就是可以在添加好友里根据名字搜索到该账号

## 10.2 公众号注册

![1570007773539](assets/1570007773539.png)

![1570007910010](assets/1570007910010.png)



## 10.3 微信公众号基本功能

### 10.3.1 自动回复

![1570008312002](assets/1570008312002.png)

	<https://kf.qq.com/faq/161221FZnEfe161221Ibmamq.html>
	
	收到消息回复在一小时内只能回复一到两条，所有有必要设置关键词回复

### 10.3.2 自定义菜单

<http://classic.getemoji.com/> 可以在这个网址中选择对应的图标，给菜单的名字添加图标

![1570009469509](assets/1570009469509.png)

![1570009558069](assets/1570009558069.png)

![1570009718993](assets/1570009718993.png)

![1570009813005](assets/1570009813005.png)

### 10.3.3 投票管理

![1576461102561](assets\1576461102561.png)

投票管理需要插入到对应的文章后才能生效

### 10.3.4 页面模板使用

#### a) 添加页面模板

![1576463387072](assets\1576463387072.png)

#### b) 绑定页面模板

![1576463332280](assets\1576463332280.png)

### 10.4 公众号后台开发

除了使用上面所提到的直接在微信公众号后台配置的基本功能之外，微信公众号还允许我们接入后台程序。需要注意的是，一旦后台接入之后，之前的配置会自动失效。

#### 10.4.1 后台接入

**a) 微信公众号后台配置**

![1576470117197](assets\1576470117197.png)

**b) node后台**

```javascript
var express = require('express');
var parseString = require('xml2js').parseString;//引入xml2js包
var app = express();


const sha1 = require('sha1');
const config = {
    appID: 'wx16b01d87eca9d8f4', //公众号里面取
    AppSecret: '41458d7494fe25ed6d957a7632d72cfa', //公众号里面取
    token: 'mytoken1234' //自定义的token
}


app.use(function (req, res, next) {
    console.log(req.method)
    if (req.method == 'GET') {
        var signature = req.query.signature,
            timestamp = req.query.timestamp,
            nonce = req.query.nonce,
            echostr = req.query.echostr;

        // token、timestamp、nonce三个参数进行字典序排序
        var arr = [config.token, timestamp, nonce].sort().join('');
        // sha1加密    
        var result = sha1(arr);
        console.log(result, signature)
        if (result === signature) {
            res.send(echostr);
        } else {
            res.send('mismatch');
        }
    }
    else{
        next()
    }
});

app.listen(8000, () => {
    console.log("running....")
})
```

**c) 将node后台端口通过ngrok映射到外网**

![1576470280500](assets\1576470280500.png)

**d) 后台接入流程**

![1576470380003](assets\1576470380003.png)

#### 10.4.2 回复消息

https://developers.weixin.qq.com/doc/offiaccount/Message_Management/Passive_user_reply_message.html

> 公众号的接口权限可在后台查询，微信公众号在定义客户端和服务端交互的时候，使用的数据格式是xml。

```
<xml>
  <ToUserName><![CDATA[toUser]]></ToUserName>
  <FromUserName><![CDATA[fromUser]]></FromUserName>
  <CreateTime>12345678</CreateTime>
  <MsgType><![CDATA[text]]></MsgType>
  <Content><![CDATA[你好]]></Content>
</xml>
```

```javascript
/**
 * 处理微信post消息请求 
 */
app.post('/', function (req, res) {
    try {
        var buffer = [];
        //监听 data 事件 用于接收数据
        req.on('data', function (data) {
            buffer.push(data);
        });
        //监听 end 事件 用于处理接收完成的数据
        req.on('end', function () {
            //输出接收完成的数据
            parseString(Buffer.concat(buffer).toString('utf-8'), { explicitArray: false }, function (err, result) {
                if (err) {
                    //打印错误信息
                    console.log(err);
                } else {
                    //打印解析结果
                    console.log(result);
                    result = result.xml;
                    var toUser = result.ToUserName; //接收方微信
                    var fromUser = result.FromUserName;//发送仿微信
                    if (result.Event === 'subscribe') {
                        //回复消息
                        var xml = returntext(fromUser, toUser, '欢迎关注公众号,hahhh');
                        console.log(xml)
                        res.send(xml)
                    } else {
                        var xml = returntext(fromUser, toUser, '您好');
                        console.log(xml)
                        res.send(xml)
                    }

                }
            })
        });
    } catch (err) {
        console.log(err)
    }
})
//回复文本消息
function returntext(toUser, fromUser, content) {
    var xmlContent = "<xml><ToUserName><![CDATA[" + toUser + "]]></ToUserName>";
    xmlContent += "<FromUserName><![CDATA[" + fromUser + "]]></FromUserName>";
    xmlContent += "<CreateTime>" + new Date().getTime() + "</CreateTime>";
    xmlContent += "<MsgType><![CDATA[text]]></MsgType>";
    xmlContent += "<Content><![CDATA[" + content + "]]></Content></xml>";
    return xmlContent;
}
```

#### 10.4.3 重新开启自定义菜单

当接入公众号后台之后，原来的自定义菜单、回复等功能会失效。如果想自定义菜单和公众号后台同时生效，我们可以在添加功能插件-->自定义菜单中开启。

![1576469739930](assets\1576469739930.png)



